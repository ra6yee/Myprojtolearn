— Интерфейс – это дитя Абстракции и Полиморфизма. Интерфейс очень напоминает абстрактный класс,
 у которого все методы абстрактные. Он объявляется так же, как и класс, только используется ключевое слово interface.
 Примеры:

 interface Drawable
 {
 void draw();
 }
 interface HasValue
 {
 int getValue();
 }
 //          1) Вместо слова class пишем interface.
 //  2) Содержит только абстрактные методы (слово abstract писать не нужно).

 //    3) На самом деле у интерфейсов все методы — public.

 interface Element extends Drawable, HasValue
 {
 int getX();
 int getY();
 }
 //           Интерфейс может наследоваться только от интерфейсов.
 //           Интерфейсов-родителей может быть много.

 abstract class ChessItem implements Drawable, HasValue
 {
 private int x, y, value;

 public int getValue()
 {
 return value;
 }

 public int getX()
 {
 return x;
 }

 public int getY()
 {
 return y;
 }

 }
 Класс может наследоваться от нескольких интерфейсов (и только от одного класса).
 При этом используется ключевое слово implements.
 Класс ChessItem объявлен абстрактным: он реализовал все унаследованные методы, кроме draw.

 Т.е. класс ChessItem содержит один абстрактный метод: draw().


  У интерфейсов есть два сильных преимущества по сравнению с классами:
  Отделение «описания методов» от их реализации.
  Раньше я тебе рассказывал, что если ты хочешь разрешить вызывать методы своего класса из других классов,
   то их нужно пометить ключевым словом public.
   Если же хочешь, чтобы какие-то методы можно было вызывать только из твоего же класса,
   их нужно помечать ключевым словом private.
   Другими словами мы делим методы класса на две категории: «для всех» и «только для своих».

  С помощью интерфейсов, это деление можно усилить еще больше.
  Мы сделаем специальный «класс для всех», и второй «класс для своих», который унаследуем от первого.
  "Класс для всех" extends "Класс дял своих"
  Вот как это примерно будет:
Было
class Student
{
 private String name;

 public Student(String name)
 {
  this.name = name;
 }

 public String getName()
 {
  return this.name;
 }

 private void setName(String name)
 {
  this.name = name;
 }
public static void main(String[] args)
{
 Student student =
               new Student("Alibaba");
 System.out.println(student.getName());
}

Стало
interface Student
{
 public String getName();
}

class StudentImpl implements Student
{
 private String name;
 public StudentImpl(String name)
 {
  this.name = name;
 }
 public String getName()
 {
  return this.name;
 }
 private void setName(String name)
 {
  this.name = name;
 }
}
public static void main(String[] args)
{
 Student student =
               new StudentImpl("Ali");
 System.out.println(student.getName());
}

Мы разбили наш класс на два: интерфейс и класс, унаследованный от интерфейса.
мы скрываем не только различные реализации, но и даже сам класс, который ее содержит
(везде в коде может фигурировать только интерфейс).
Это позволяет очень гибко, прямо в процессе исполнения программы, подменять одни объекты на другие,
меняя поведение объекта скрытно от всех классов, которые его используют.

Это очень мощная технология в сочетании с полиморфизмом.
Сейчас далеко не очевидно, зачем так нужно делать.
Ты должен сначала столкнуться с программами, состоящими из десятков или сотен классов, чтобы понять,
что интерфейсы способны существенно упростить тебе жизнь.

В Java пришли к компромиссу – запретили множественное наследование классов,
 но разрешили множественное наследование интерфейсов.
Интерфейс может иметь несколько интерфейсов-родителей.
 Класс может иметь несколько интерфейсов-родителей и только один класс-родитель.


 класс – это, чаще всего модель какого-то конкретного объекта.
 Интерфейс же больше соответствует не объектам, а их способностям или ролям.
Например, такие вещи, как машина, велосипед, мотоцикл и колесо лучше всего представить в виде классов и объектов.
А такие их способности как «могу ездить», «могу перевозить людей», «могу стоять» — лучше представить в виде интерфейсов.

Смотри пример:

Код на Java	Описание
interface Moveable
{
void move(String newAddress);
}	— соответствует способности передвигаться.
interface Driveable
{
void drive(Driver driver);
}	— соответствует способности управляться водителем.
interface Transport
{
void addStaff(Object staff);
Object removeStaff();
}	— соответствует способности перевозить грузы.
class Wheel implements Moveable
{
...
}	— класс «колесо». Обладает способностью передвигаться.
class Car implements Moveable, Drivable, Transport
{
...
}	— класс «машина». Обладает способностью передвигаться, управляться человеком и перевозить грузы.
class Skateboard implements Moveable, Driveable
{
...
}	— класс «скейтборд». Обладает способностью передвигаться и управляться человеком.

Интерфейсы сильно упрощают жизнь программиста.
Очень часто в программе тысячи объектов, сотни классов и всего пара десятков интерфейсов – ролей. Ролей мало,
 а их комбинаций – классов – очень много.

Весь смысл в том, что тебе не нужно писать код для взаимодействия со всеми классами.
Тебе достаточно взаимодействовать с их ролями (интерфейсами).

Представь, что ты – робот-строитель и у тебя в подчинении есть десятки роботов, каждый из которых может иметь несколько
 профессий. Тебе нужно срочно достроить стену.
 Ты просто берешь всех роботов, у которых есть способность «строитель» и говоришь им строить стену.
 Тебе все равно, что это за роботы. Хоть робот-поливалка. Если он умеет строить – пусть идет строить.

Вот как это выглядело бы в коде:

Код на Java	Описание
static interface WallBuilder
{
void buildWall();
}	— способность «строитель стен». Понимает команду «(по)строить стену» — имеет соответствующий метод.
static class РабочийРобот implements WallBuilder
{
void buildWall()
 {
…
 }
}
static class РоботСторож implements WallBuilder
{
void buildWall()
 {
…
 }
}
static class Поливалка
{
…
}	— роботы у которых есть эта профессия/особенность.
— для удобства я сделал классам имена на русском. Такое допускается в java, но крайне нежелательно.

— поливалка не обладает способностью строить стены (не реализует интерфейс WallBuilder).

public static void main(String[] args)
{
 //добавляем всех роботов в список
 ArrayList robots = new ArrayList();
 robots.add(new РабочийРобот());
 robots.add(new РоботСторож());
 robots.add(new Поливалка());

 //строить стену, если есть такая способность
 for (Object robot: robots)
 {
  if (robot instanceof WallBuilder)
  {
   WallBuilder builder = (WallBuilder) robot;
   builder.buildWall();
   }
  }
 }
}

интерфейс может определять константы и методы, которые могут иметь, а могут и не иметь реализации.
 public interface WeatherType {
        String CLOUDY = "Cloudy";
        String FOGGY = "Foggy";
        String FREEZING = "Freezing";
           final String NAME = "Submit";
 // final  можно стереть, потому что в интерфейсе все поля и так константы, поэтому их название пишутся в верхнем регистре.
    }

Быстро решил, но тупил, почему можно в классе Solution написать например: WeatherType.CLOUDY,
потому-что все константы в интерфейсах public final static и к ним можно обратиться через имя класса/интерфейса через точку.


