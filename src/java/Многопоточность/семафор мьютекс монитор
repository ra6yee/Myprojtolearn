Мьютекс
Мьютекс — это специальный объект для синхронизации потоков. Он «прикреплен» к каждому объекту в Java.

Неважно, пользуешься ли ты стандартными классами или создал собственные классы, скажем, Cat и Dog: у всех объектов всех
 классов есть мьютекс.

Название «мьютекс» происходит от английского «MUTual EXclusion» — «взаимное исключение», и это отлично отражает его
 предназначение.

Задача мьютекса — обеспечить такой механизм, чтобы доступ к объекту в определенное время был только у одного потока.


У мьютекса есть несколько важных особенностей.

Во-первых, возможны только два состояния — «свободен» и «занят».

Это упрощает понимание принципа работы: можно провести параллели с булевыми переменными true/false или двоичной системой
 счисления 1/0.

Во-вторых, состояниями нельзя управлять напрямую. В Java нет механизмов, которые позволили бы явно взять объект,
 получить его мьютекс и присвоить ему нужный статус.


Монитор
Монитор — это дополнительная «надстройка» над мьютексом.

Фактически монитор — это «невидимый» для программиста кусок кода.

Говоря о мьютексе ранее, мы приводили простой пример:

public class Main {

   private Object obj = new Object();

   public void doSomething() {

       //...какая-то логика, доступная для всех потоков

       synchronized (obj) {

           //логика, которая одновременно доступна только для одного потока
       }
   }
}

В блоке кода, который помечен словом synchronized, происходит захват мьютекса нашего объекта obj.

Хорошо, захват-то происходит, но как именно обеспечивается «защитный механизм»? Почему при виде слова synchronized
остальные потоки не могут пройти внутрь блока?

Защитный механизм создает именно монитор! Компилятор преобразует слово synchronized в несколько специальных кусков кода.

Еще раз вернемся к нашему примеру с методом doSomething() и дополним его:

public class Main {

   private Object obj = new Object();

   public void doSomething() {

       //...какая-то логика, доступная для всех потоков

       //логика, которая одновременно доступна только для одного потока
       synchronized (obj) {

           /*выполнить важную работу, при которой доступ к объекту
           должен быть только у одного потока*/
           obj.someImportantMethod();
       }
   }
}

Вот что будет происходить «под капотом» нашей программы после того, как компилятор преобразует этот код:

public class Main {

   private Object obj = new Object();

   public void doSomething() throws InterruptedException {

       //...какая-то логика, доступная для всех потоков

       //логика, которая одновременно доступна только для одного потока:

       /*до тех пор, пока мьютекс объекта занят -
       любой другой поток (кроме того, который его захватил), спит*/
       while (obj.getMutex().isBusy()) {
           Thread.sleep(1);
       }

       //пометить мьютекс объекта как занятый
       obj.getMutex().isBusy() = true;

       /*выполнить важную работу, при которой доступ к объекту
       должен быть только у одного потока*/
       obj.someImportantMethod();

       //освободить мьютекс объекта
       obj.getMutex().isBusy() = false;
   }
}

Пример, конечно, ненастоящий. Здесь мы с помощью Java-подобного кода попытались отразить то, что происходит в этот
момент внутри Java-машины. Однако этот псевдокод дает отличное понимание того, что на самом деле происходит с объектом
и потоками внутри блока synchronized и как компилятор преобразует это слово в несколько «невидимых» для программиста
 команд.

По сути, монитор в Java выражен с помощью слова synchronized. Весь код, который появился вместо слова synchronized в
последнем примере, — это и есть монитор.

Семафор — это средство для синхронизации доступа к какому-то ресурсу.

Его особенность заключается в том, что при создании механизма синхронизации он использует счетчик.

Счетчик указывает нам, сколько потоков одновременно могут получать доступ к общему ресурсу.

Семафоры в Java представлены классом Semaphore.

При создании объектов-семафоров мы можем использовать такие конструкторы:

Semaphore(int permits)
Semaphore(int permits, boolean fair)

В конструктор мы передаем:
int permits — начальное и максимальное значение счетчика. То есть то, сколько потоков одновременно могут иметь доступ к
общему ресурсу;

boolean fair — для установления порядка, в котором потоки будут получать доступ. Если fair = true, доступ
предоставляется ожидающим потокам в том порядке, в котором они его запрашивали. Если же он равен false, порядок будет
определять планировщик потоков.


Ты мог заметить некоторое сходство между мьютексом и семафором.

У них, в общем-то, одинаковое предназначение: синхронизировать доступ к какому-то ресурсу.
В чем разница между мьютексом, монитором и семафором - 5Разница только в том, что мьютекс объекта может захватить
одновременно только один поток, а в случае с семафором используется счетчик потоков, и доступ к ресурсу могут получить
сразу несколько из них. И это не просто случайное сходство :)

На самом деле мьютекс — это одноместный семафор. То есть, это семафор, счетчик которого изначально установлен в значении
 1. Его еще называют «двоичным семафором», поскольку его счетчик может иметь только 2 значения — 1 («свободно»)
 и 0 («занято»).

Вот и все! Как видишь, все оказалось не таким уж и запутанным :) Теперь, если ты захочешь изучить тему многопоточности
подробнее в Интернете, тебе будет чуть проще ориентироваться в понятиях. До встречи на следующих уроках!









