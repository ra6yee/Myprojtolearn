— На самом деле нечто подобное существует в классе Thread. Только переменная называется не isCancel, а isInterrupt
 и метод остановки, соответственно, не cancel(), а interrupt().


 class Clock implements Runnable {
  public void run() {
   Thread current = Thread.currentThread();

   while (!current.isInterrupted()) {
    try {
     Thread.sleep(1000);
    } catch (InterruptedException e) {
     e.printStackTrace();
    }
    System.out.println("Tik");
   }
  }
 }

 public static void main(String[] args) throws Exception {
  Clock clock = new Clock();
  Thread clockThread = new Thread(clock);
  clockThread.start();

  Thread.sleep(10000);
  clockThread.interrupt();
 }
Т.к. много нитей могут вызвать метод run одного объекта,
то объект Clock в своем методе run получает объект вызвавшей его нити («текущей нити»).
Класс Clock (часы) будет писать в консоль раз в секунду слово «Tik»,
 пока переменная isInterrupt текущей нити равна false.
Когда переменная isInterrupt станет равной true, метод run завершится.

Более того, в методе sleep, который так любят использовать для организации вечного цикла в методе run,
 есть автоматическая проверка переменной isInterrupt. Если нить вызовет метод sleep,
 то этот метод сначала проверит, а не установлена ли для текущей (вызвавшей его нити) переменная isInterrupt в true.
  И если установлена, то метод не будет спать, а выкинет исключение InterruptedException.

— А зачем выкидывать исключение? Не лучше ли тоже просто в цикле вместо isCancel подставить isInterrupted()?

— Во-первых, не всегда в методе run есть цикл. Метод может состоять просто из двух десятков вызовов других методов.
 Тогда перед вызовом каждого придется добавлять проверку isInterrupted.

Во-вторых, вдруг какой-то метод очень долго исполняется, т.к. делает много разных действий.

В-третьих, выкидывание исключения – это не замена проверке isInterrupted, а скорее удобное дополнение.
 Выкинутое исключение позволяет быстро раскрутить стек вызовов до самого run.

В-четвертых, метод sleep часто используют и получается к такому полезному методу неявно добавили не менее полезную
проверку. Вроде бы никто специально проверку не добавлял, а она есть. Это очень ценно когда ты используешь много
чужого кода и не можешь сам добавить в него проверку.

В-пятых, дополнительная проверка не приводит к снижению производительности. Вызов метода sleep значит
 что нить должна ничего не делать (спать) поэтому дополнительная работа никому не мешает.

— Серьёзные аргументы.

— И, наконец, последнее: ты можешь в своем методе run вызывать чужой код к которому у тебя нет доступа
 (исходников и/или прав их менять). Он может не иметь проверок на isInterrupted,
 а также перехватывать с помощью try…catch(Exception e) все возникшие исключения.

Никто не гарантирует, что нить можно остановить. Она может остановиться только сама.


У объектов типа Thread есть логическое поле/флаг со значением false по умолчанию.
ОбъектПотока.interrupt() - просто меняет этот флаг на true, чтобы условие цикла
while (!current.isInterrupted()) {}

стало ложным и он оборвался.
.isInterrupted() как раз возвращает значение флага.

Проблема в том, что при использовании статического метода класса Thread - Thread.sleep(10000) и ОбъектПотока.join()
программа "засыпает", и следовательно, никаких проверок условия while не происходит.

Короче говоря, если поток заснет на 100 лет, а мы его прервем, то узнает он об этом лишь по прошествии этих 100 лет,
так как условия выхода из цикла никто не проверял все это время. Именно поэтому метод join и sleep постоянно проверяют,
не был ли изменен флаг текущего потока, и если был, то нафиг ждать 100 лет,
выбрасываем InterruptedException и поехали дальше.

Поэтому:
" Более того, в методе sleep, который так любят использовать для организации вечного цикла в методе run,
есть автоматическая проверка переменной isInterrupt. Если нить вызовет метод sleep, то этот метод сначала проверит,
а не установлена ли для текущей (вызвавшей его нити) переменная isInterrupt в true.
И если установлена, то метод не будет спать, а выкинет исключение InterruptedException. "




//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
interrupt() - ставит флаг треда на true (тред прерван)
isInterrupted() - не статический метод для проверки флага (не трогает значение флага)
Thread.interrupted() - статический метод Thread, который проверяет значение флага и сбрасывает его (переводит в false)
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


Важно знать, что wait, join и sleep (все то, что бросает исключение InterruptedException)
осуществляет проверку через Thread.interrupted(), а не isInterrupted().

Это важно, потому что иначе получится неожиданная ситуация, например, такая:
public void run() {
    while (!Thread.currentThread().isInterrupted()) {
        System.out.println(("Тред работает"));
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

Если тред прервется во время "сна", то будет выброшено InterruptedException, а флаг вернется в состояние false.
 Из-за этого тред продолжит свою работу, даже не зная, что был прерван.

 В конкретном примере это можно исправить либо так:
public void run() {
    try {
        while (!Thread.currentThread().isInterrupted()) {
            System.out.println(("Тред работает"));
            Thread.sleep(1000);
        }
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}

Либо так:
public void run() {
    while (!Thread.currentThread().isInterrupted()) {
        System.out.println(("Тред работает"));
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
            Thread.currentThread().interrupt();
        }
    }
}





