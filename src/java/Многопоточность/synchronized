Блокировка нитей. И вот как это работает.

Было выяснено, что нити мешают друг другу, когда пытаются сообща работать с общими объектами и/или ресурсами.
 Как в примере с выводом на консоль: консоль одна, а выводят на нее все нити. Непорядок.

Поэтому был придуман специальный объект – мютекс. Это как табличка на двери туалета «свободно» «занято».
 Он имеет два состояния – объект свободен и объект занят, или их еще называют заблокирован и разблокирован.

Когда какой-то нити нужен общий для всех нитей объект, она проверяет мютекс, связанный с этим объектом.
Если мютекс свободен, то нить блокирует его (помечает как занятый) и начинает использование общего ресурса.
После того, как она сделала свои дела, мютекс разблокируется (помечается как свободен).

Если же нить хочет использовать объект, а мютекс заблокирован, то нить засыпает в ожидании. Когда мютекс, наконец,
 освободится занятой нитью, наша нить тут же заблокирует его и приступит к работе.
  Аналогия с табличками для туалета один в один.
 Разработчики Java встроили этот мютекс в класс Object. Тебе даже создавать его не придется. Он есть у каждого объекта.
    Вот как это все работает:
class MyClass
{
private String name1 = "Оля";
private String name2 = "Лена";

public void swap()
{
synchronized (this)
{
String s = name1;
name1 = name2;
name2 = s;
}
}
}

 если вызывать этот код одновременно из двух нитей, то будет так:

Итоговый порядок
String s1 = name1; //Оля
name1 = name2; //Лена
name2 = s1; //Оля

String s2 = name1; //Лена
name1 = name2; //Оля
name2 = s2; //Лена

Код первой нити
String s1 = name1;
name1 = name2;
name2 = s1;
//исполняется другая нить
//исполняется другая нить
//исполняется другая нить

Код второй нити
//нить ждет, пока освободится мютекс
//нить ждет, пока освободится мютекс
//нить ждет, пока освободится мютекс
String s2 = name1;
name1 = name2;
name2 = s2;

Итог
Значения переменных были дважды обменяны местами и вернулись на первоначальное место.

— Когда одна нить заходит внутрь блока кода, помеченного словом synchronized, то Java-машина тут же блокирует мютекс
у объекта, который указан в круглых скобках после слова synchronized. Больше ни одна нить не сможет зайти в этот блок,
 пока наша нить его не покинет.
Как только наша нить выйдет из блока, помеченного synchronized, то мютекс тут же автоматически разблокируется и будет
свободен для захвата другой нитью.

— Ага. А как ты думаешь, что будет в этом случае?

Код	Описание
class MyClass
{
private String name1 = "Оля";
private String name2 = "Лена";

public void swap()
{
synchronized (this)
{
String s = name1;
name1 = name2;
name2 = s;
}
}

public void swap2()
{
synchronized (this)
{
String s = name1;
name1 = name2;
name2 = s;
}
}
}
Методы swap и swap2 имеют один и тот же мютекс – объект this.
Что будет, если одна нить вызовет метод swap, а другая – метод swap2?

— Т.к. мютекс у них один, то второй нити придется ждать, пока первая нить выйдет из блока synchronized,
 поэтому проблем с одновременным доступом тут не будет.

Хотелось бы обратить твое внимание на то, что словом synchronized может быть помечен как кусок кода, так и метод.
 Вот что это значит:


class MyClass
{
private static String name1 = "Оля";
private static String name2 = "Лена";

public synchronized void swap()
{
String s = name1;
name1 = name2;
name2 = s;
}

public static synchronized void swap2()
{
String s = name1;
name1 = name2;
name2 = s;
}
}
,.......................................................................................................................

Как работает оператор synchronized в Java
Давай познакомимся с новым ключевым словом — synchronized.

Им помечается определенный кусок нашего кода. Если блок кода помечен ключевым словом synchronized, это значит
 что блок может выполняться только одним потоком одновременно.

Синхронизацию можно реализовать по-разному. Например, создать целый синхронизированный метод:

public synchronized void doSomething() {

   //...логика метода
}

Или же написать блок кода, где синхронизация осуществляется по какому-то объекту:

public class Main {

   private Object obj = new Object();

   public void doSomething() {

       //...какая-то логика, доступная для всех потоков

       synchronized (obj) {

           //логика, которая одновременно доступна только для одного потока
       }
   }
}

Смысл прост. Если один поток зашел внутрь блока кода, который помечен словом synchronized, он моментально захватывает
 мьютекс объекта, и все другие потоки,
 которые попытаются зайти в этот же блок или метод вынуждены ждать
  пока предыдущий поток не завершит свою работу и не освободит монитор.



Некоторые важные замечания
Синхронизация в Java гарантирует, что никакие два потока не смогут выполнить синхронизированный метод одновременно или
 параллельно.

synchronized можно использовать только с методами и блоками кода. Эти методы или блоки могут быть статическими или
 не-статическими.

когда какой либо поток входит в синхронизированный метод или блок он приобретает блокировку и всякий раз, когда поток
выходит из синхронизированного метода или блока JVM снимает блокировку.
 Блокировка снимается, даже если нить оставляет синхронизированный метод после завершения из-за каких-либо ошибок или исключений.

synchronized в Java рентерабельна это означает, что если синхронизированный метод вызывает другой
синхронизированный метод, который требует такой же замок, то текущий поток, который держит замок может войти в этот
метод не приобретая замок.

Синхронизация в Java будет бросать NullPointerException если объект используемый в синхронизированном блоке null.
Например, в вышеприведенном примере кода, если замок инициализируется как null,
синхронизированный (lock) бросит NullPointerException.

Синхронизированные методы в Java вносят дополнительные затраты на производительность вашего приложения.
Так что используйте синхронизацию, когда она абсолютно необходима. Кроме того, рассмотрите вопрос об использовании
синхронизированных блоков кода для синхронизации только критических секций кода.

Вполне возможно, что и статический и не статический синхронизированные методы могут работать одновременно или
 параллельно, потому что они захватывают замок на другой объект.

В соответствии со спецификацией языка вы не можете использовать synchronized в конструкторе это приведет к
ошибке компиляции.

Не синхронизируйте по не финальному (no final) полю, потому что ссылка, на не финальное поле может измениться в любое
 время, а затем другой поток может получить синхронизацию на разных объектах и уже не будет никакой синхронизации вообще.
  Лучше всего использовать класс String, который уже неизменяемый и финальный.


