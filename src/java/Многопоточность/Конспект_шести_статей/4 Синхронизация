С понятием монитора, как мы ранее видели, тесно связано понятие "блок синхронизации"
(или как ещё называют — критическая секция).

Взглянем на пример:

public static void main(String[] args) throws InterruptedException {
	Object lock = new Object();

	Runnable task = () -> {
		synchronized (lock) {
			System.out.println("thread");
		}
	};

	Thread th1 = new Thread(task);
	th1.start();
	synchronized (lock) {
		for (int i = 0; i < 8; i++) {
			Thread.currentThread().sleep(1000);
			System.out.print("  " + i);
		}
		System.out.println(" ...");
	}
}

Здесь главный поток сначала отправляет задачу task в новый поток, а потом сразу же "захватывает" лок и выполняет с ним
долгую операцию (8 секунд). Всё это время task не может для своего выполнения зайти в блок synchronized, т.к. лок уже
занят.

Если поток не может получить лок, он будет ждать этого у монитора. Как только получит — продолжит выполнение. Когда
поток выходит из-под монитора, он освобождает лок.

Кроме блоков синхронизации может быть синхронизирован целый метод. Например, метод из класса HashTable:

public synchronized int size() {
	return count;
}

В одну единицу времени данный метод будет выполняться только одним потоком. Но ведь нам нужен лок? Да, нужен. В случае
методов объекта локом будет выступать this.

Если метод статический, то локом будет не this (т.к. для статического метода не может быть this), а объект класса
(Например, Integer.class).

Синхронизация может выполняться без указания объекта. Это можно сделать, когда синхронизирован не отдельный участок кода,
 а целый метод.

Например, для статических методов локом будет объект класса (полученный через .class):

public static synchronized void printA() {
	System.out.println("A");
}
public static void printB() {
	synchronized(HelloWorld.class) {
		System.out.println("B");
	}
}

С точки зрения использования локов оба метода одинаковы.

Если метод не статический, то синхронизация будет выполняться по текущему instance, то есть по this.



