в компьютере есть память, где хранятся данные и команды (код), а также процессор, который исполняет эти команды и
работает с данными. Процессор считывает данные из памяти, изменяет и записывает их обратно в память.
Чтобы ускорить работу процессора в него встроили свою «быструю» память – кэш.

Чтобы ускорить свою работу, процессор копирует самые часто используемые переменные из области памяти в свой кэш и все
изменения с ними производит в этой быстрой памяти. А после – копирует обратно в «медленную» память.
Медленная память все это время содержит старые(!) (неизмененные) значения переменных.

И тогда может возникнуть проблема. Одна нить меняет переменную, такую как isCancel или isInterrupted из примера ниже,
 а вторая нить «не видит» этого изменения, т.к. оно было совершено в быстрой памяти. Это следствие того, что нити
 не имеют доступа к кэшу друг друга. (Процессор часто содержит несколько независимых ядер и нити физически могут
 исполняться на разных ядрах.)

Вспомним вчерашний пример:
class Clock implements Runnable
{
private boolean isCancel = false;

public void cancel()
{
this.isCancel = true;
}                                      нить незнает о существовании другой нити.
                               В методе run переменная isCancel при первом использовании будет помещена в кэш дочерней нити.
public void run()               Вызов метода cancel из другой нити поменяет значение переменной isCancel в обычной
{                                 (медленной) памяти, но не в кэше остальных нитей.
while (!this.isCancel)
{
Thread.sleep(1000);
System.out.println("Tik");
}
}
}
public static void main(String[] args)
{
Clock clock = new Clock();
Thread clockThread = new Thread(clock);
clockThread.start();

Thread.sleep(10000);
clock.cancel();
}
Было придумано специальное ключевое слово volatile. Помещение его перед определением переменной запрещало помещать
ее значение в кэш. Вернее не запрещало помещать в кэш, а просто принудительно всегда читало и писало ее только в
 обычную (медленную) память.

Вот как нужно исправить наше решение, чтобы все стало отлично работать:
class Clock implements Runnable
{
private volatile boolean isCancel = false;

public void cancel()
{
this.isCancel = true;
}

public void run()
{
while (!this.isCancel)
{
Thread.sleep(1000);
System.out.println("Tik");
}
}
}
Из-за модификатора volatile чтение и запись значения переменной всегда будут происходить в обычной,
общей для всех нитей, памяти.


