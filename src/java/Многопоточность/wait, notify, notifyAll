ти методы были придуманы как часть механизма синхронизации нитей.

Напомню, что в Java есть встроенный механизм управления доступом к общим ресурсам (объектам) из разных нитей. Нить может
 объявить какой-нибудь объект занятым, и другие нити будут вынуждены ждать, пока занятый объект не освободится.

— Я помню, это делается с помощью ключевого слова synchronized.

— Правильно. Обычно такой код выглядит примерно так:

public void print()
{
 Object monitor = getMonitor();
 synchronized(monitor)
 {
  System.out.println("text");
 }
}
Помнишь, как это работает?

— Ага. Если две нити одновременно вызовут метод print(), то одна из них войдет в блок, помеченный synchronized и
заблокирует monitor, поэтому вторая нить будет ждать, пока монитор не освободится.

— Правильно. Как только нить входит в блок, помеченный synchronized, то объект-монитор помечается как занятый и
другие нити будут вынуждены ждать освобождения объекта-монитора. Один и тот же объект-монитор может использоваться в
различных частях программы.

— Кстати, почему – монитор?

— Монитором принято называть объект, который хранит состояние занят/свободен.

Вот тут и вступают в дело методы wait и notify.

Собственно, методов как таковых всего два. Остальные – это лишь модификации этих методов.

Теперь разберемся, что же такое метод wait и зачем он нужен.

Иногда в программе может оказаться такая ситуация, что нить вошла в блок кода synchronized, заблокировала монитор и не
может работать дальше, т.к. каких-то данных еще не хватает: например, файл который она должна обработать еще не
загрузился или что-нибудь в таком духе.

Мы же можем просто подождать, когда файл скачается. Можно просто в цикле проверять – если файл еще не скачался – спать,
например, секунду и опять проверять и т.д.

Примерно так:

while(!file.isDownloaded())
{
 Thread.sleep(1000);
}
processFile(file);
Но в нашем случае такое ожидание слишком дорого. Т.к. наша нить заблокировала монитор, то другие нити вынуждены тоже
ждать, хотя их данные для работы могут быть уже готовы.

Для решения этой проблемы и был придуман метод wait(). Вызов этого метода приводит к тому, что нить освобождает монитор
и «становится на паузу».

Метод wait можно вызвать у объекта-монитора и только тогда, когда это монитор занят – т.е. внутри блока synchronized.
При этом нить временно прекращает работу, а монитор освобождается, чтобы им могли воспользоваться другие нити.

Часто встречаются ситуации, когда в блок synchronized зашла нить, вызвала там wait, освободила монитор.

Затем туда вошла вторая нить и тоже стала на паузу, затем третья и так далее.

— А как же нить снимется с паузы?

— Для этого есть второй метод – notify.

Методы notify/notifyAll можно вызвать у объекта-монитора и только, когда этот монитор занят – т.е. внутри блока
synchronized. Метод notifyAll снимает с паузы все нити, которые стали на паузу с помощью данного объекта-монитора.

Метод notify «размораживает» одну случайную нить, метод notifyAll – все «замороженные» нити данного монитора.

— Очень интересно, спасибо Риша.

— Рад, что тебе нравится, Амиго!

Есть еще модификации метода wait():

Метод wait()	Пояснение
void wait(long timeout)
Нить «замерзает», но через переданное количество миллисекунд автоматически «размораживается».
void wait(long timeout, int nanos)
Нить «замерзает», но через переданное количество миллисекунд и наносекунд автоматически «размораживается».
Это, как еще говорят, wait с таймаутом. Метод работает как обычный wait, но если указанное время прошло, а нить никто не
 снял с паузы – она активируется сама.

Хочется дополнить лекцию не менее важной деталью. Допустим, у нас есть два потока: T1, T2. Есть один метод: doSomething().
 Предположим, что он будет выглядеть вот таким образом:

public synchronized void doSomething() throws InterruptedException {
        notify();

        // Что-то делаем в этом методе.

        wait();
    }


Запускаем два потока, которые в себе содержат только вызов метода doSomething(). Получается, что два потока обращаются
к синхронизированному методу doSomething(). Кто успеет перехватить монитор - тот первый и войдет.
Хорошо, какой-то поток из T1, T2 зайдет в метод. Другой же будет ожидать, когда тот освободит монитор. Допустим, первый
 зашедший поток в метод был T1. Он выполнит метод notify(). То есть, попытается разбудить поток, который отдавал свой
  монитор другому потоку. Но т.к таких нет, по сути никто и не проснется. Хорошо, движемся дальше. Поток T1 выполнит
  ЧТО-ТО и по итогу заснет (wait), отдав свой монитор другому потоку. Получается, что у потока T2 появилась возможность
  зайти в метод doSomething(). Он, не зевая, перехватывает монитор и заходит в данный метод. На первой строчке он
  пытается разбудить поток, который отдавал свой монитор. Поток T1 проснется, но свое выполнение он не продолжит. А всё
   потому, что монитор перехвачен потоком T2. Поэтому ему остается ждать, когда монитор снова будет освобожден. То есть,
    самая главная деталь - это то, что после вызова notify() пробудившийся поток не сразу продолжает свое выполнение, а
    сначала проверяет, свободен ли монитор. Если он занят, то поток будет дожидаться, когда монитор будет освобожден.

В данном примере какой-то из поток T1, T2 вечно заснет, ожидая, когда кто-то его пробудит.


public class JobQueue
{
 ArrayList jobs = new ArrayList();

 public synchronized void put(Runnable job)
 {
  jobs.add(job);
  this.notifyAll();
 }

 public synchronized Runnable getJob()
 {
  while (jobs.size()==0)
   this.wait();

  return jobs.remove(0);
 }
}

У нас есть метод getJob, который смотрит, если список работы (jobs) пуст, то нить засыпает (wait), пока в списке что-то
не появится.

А есть еще метод put, который позволяет добавить в список jobs новое задание (job). Как только новое задание добавлено,
 вызывается метод notifyAll. Вызов этого метода пробудит все нити-исполнители, которые заснули внутри метода getJob.

— А можешь напомнить еще раз, как работают методы wait и notify?

— Метод wait вызывается только внутри блока synchronized, у объекта-мютекса. В нашем случае – это this. При этом
происходят две вещи:

1) Нить засыпает.

2) Нить временно освобождает мютекс (пока не проснется).

После этого другие нити могу входить в блок synchronized и занимать этот же мютекс.

Метод notifyAll тоже можно вызвать только внутри блока synchronized у объекта-мютекса. В нашем случае – это this. При
этом происходят две вещи:

1) Просыпаются все нити, которые заснули на этом же объекте-мютексе.

2) Как только текущая нить выйдет из блока synchronized, одна из проснувшихся нитей захватит мютекс и продолжит свою
 работу. Когда она освободит мютекс, другая проснувшаяся нить захватит мютекс и т.д.


И еще пара деталей. Так сказать практических советов.

Пусть у тебя есть метод, который что-то ждет и засыпает, пока условие не выполнено.

Если коллекция пустая, то ждем

public synchronized Runnable getJob()
{
 if (jobs.size()==0)
  this.wait();

 return jobs.remove(0);
}
В документации по Java очень старательно советуют вызвать метод wait в цикле:

Если коллекция пустая, то ждем
public synchronized Runnable getJob()
{
 while (jobs.size()==0)
  this.wait();

 return jobs.remove(0);
}
Зачем это надо. Дело в том, что если нить разбудили – это еще не значит, что условие выполнится. Может, там таких спящих
 нитей было два десятка. Разбудили всех, а задание забрать сможет только одна.

Грубо говоря, могут быть «ложные побудки». Хороший разработчик должен учитывать это дело.

— Ясно. А не проще ли тогда использовать просто notify?

— А если в списке больше чем одно задание? Notify обычно советуют использовать ради оптимизации. Во всех остальных
 случаях рекомендуют использовать метод notifyAll.

— Ок.

— Но и это еще не все. Во-первых, может возникнуть ситуация, когда кто-то унаследовался от твоего класса, добавил туда
свои методы и тоже использует wait/notifyAll. Т.е. может быть ситуация, когда на одном объекте висят независимые пары
wait/notifyAll, которые друг о друге не знают. Поэтому что надо делать?

— Всегда вызывать wait в цикле и проверять, что условие выхода из цикла действительно выполнилось!

— Правильно. А чтобы тебе стало совсем понятно, что от этого никуда не деться, то многие разработчики указывают на то,
 что иногда нити просыпаются сами. Нити, которые гарантированно никто не может будить случайно. Похоже это побочный
 процесс оптимизации/ускорения кода в работающей Java-машине.

— Ничего себе. Понял, без цикла перед wait никуда.

