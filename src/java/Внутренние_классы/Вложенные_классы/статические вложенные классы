При объявлении такого класса мы используем ключевое слово static:

public class Boeing737 {

   private int manufactureYear;
   private static int maxPassengersCount = 300;

   public Boeing737(int manufactureYear) {
       this.manufactureYear = manufactureYear;
   }

   public int getManufactureYear() {
       return manufactureYear;
   }

  !!!!! public static class Drawing {!!!!!

       public static int getMaxPassengersCount() {

           return maxPassengersCount;
       }
   }
}
 создание такого вложенного класса повышает инкапсуляцию и способствует более реалистичной абстракции.

В чем же отличие между статическим и нестатическим вложенными классами?

1. Объект статического класса Drawing не хранит ссылку на конкретный экземпляр внешнего класса.
бъект статического вложенного класса вполне может существовать сам по себе.
В этом плане статические классы более «независимы», чем нестатические.

Единственный момент — при создании такого объекта нужно указывать название внешнего класса:

public class Main {

   public static void main(String[] args) {

       Boeing737.Drawing drawing1 = new Boeing737.Drawing();
       Boeing737.Drawing drawing2 = new Boeing737.Drawing();
   }
}
Как и в прошлый раз, давай добавим немного «философии» для понимания примера :)

В отличие от сиденья велосипеда, сущность чертежа не привязана так жестко к сущности самолета.

Отдельный объект сиденья, без велосипеда, чаще всего будет бессмысленным (хотя и не всегда — мы говорили об этом на
прошлом занятии).

Сущность чертежа имеет смысл сама по себе. Например, он может пригодиться инженерам, планирующим ремонт самолета. Сам
самолет для планирования им не нужен, и может находиться где угодно — достаточно просто чертежа.

Кроме того, для всех самолетов одной модели чертеж все равно будет одинаковым, так что такой жесткой связи, как у
сиденья с велосипедом, нет. Поэтому и ссылка на конкретный объект самолета объекту Drawing не нужна.

2. Разный доступ к переменным и методам внешнего класса.

!!!!!!!!!!!Статический вложенный класс может обращаться только к статическим полям внешнего класса.!!!!!!!!!!!!!!!!!

В нашем примере в классе Drawing есть метод getMaxPassengersCount(), который возвращает значение статической переменной
 maxPassengersCount из внешнего класса.

Однако мы не можем создать метод getManufactureYear() в Drawing для возврата значения manufactureYear. Ведь переменная
 manufactureYear — нестатическая, а значит, должна принадлежать конкретному экземпляру Boeing737. А как мы уже выяснили,
в случае со статическими вложенными классами объект внешнего класса запросто может отсутствовать. Отсюда и ограничение :)

При этом неважно, какой модификатор доступа имеет статическая переменная во внешнем классе. Даже если это private,
доступ из статического вложенного класса все равно будет.

Все вышесказанное касается не только доступа к статическим переменным, но и к статическим методам.

ВАЖНО!

Слово static в объявлении внутреннего класса не означает, что можно создать всего один объект. Не путай объекты с
переменными.

Если мы говорим о статических переменных — да, статическая переменная класса, например, maxPassangersCount, существует в
 единственном экземпляре.

Но применительно ко вложенному классу static означает лишь то, что его объекты не содержат ссылок на объекты внешнего
класса. А самих объектов мы можем создать сколько угодно:

public class Boeing737 {

   private int manufactureYear;
   private static int maxPassengersCount = 300;

   public Boeing737(int manufactureYear) {
       this.manufactureYear = manufactureYear;
   }

   public int getManufactureYear() {
       return manufactureYear;
   }

   public static class Drawing {

       private int id;

       public Drawing(int id) {
           this.id = id;
       }

       public static int getPassengersCount() {

           return maxPassengersCount;
       }

       @Override
       public String toString() {
           return "Drawing{" +
                   "id=" + id +
                   '}';
       }

       public static void main(String[] args) {

           for (int i = 1; i < 6; i++) {

               Boeing737.Drawing drawing = new Boeing737.Drawing(i);
               System.out.println(drawing);
           }
       }
   }
}

Мы объявили метод main() прямо во вложенном классе (особой причины для этого нет — просто чтобы ты знал, что так можно),
 и создали 5 объектов Drawing. При том, что ни одного объекта внешнего класса у нас нет.

Как видишь, никаких проблем не возникло :)

Вывод в консоль:

Drawing{id=1}
Drawing{id=2}
Drawing{id=3}
Drawing{id=4}
Drawing{id=5}


