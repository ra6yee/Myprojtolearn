Метод еquals() используется для сравнения объектов, а hashCode - для генерации целочисленного кода объекта.

Эти методы широко используются в стандартных библиотеках Java при вставке и извлечению объектов в HashMap.
 Метод equal также используется для обеспечения хранения только уникальных объектов в HashSet и других Set реализациях,
 а также в любых других случаях, когда нужно сравнивать объекты.

 Важно!!! При вызове метода equals(), сначала вызывается метод HashCode(). Хаш код генерирует хеш код объекта.Непонятно
 как только он генерирует хешкод для String.
 Возвращает цельночисленное значение
 ///////////////////////////////////////////
 Если объекты равны по результатам выполнения метода equals, тогда их hashcode должны быть одинаковыми.
 Если объекты не равны по результатам выполнения метода equals, тогда их hashcode могут быть как одинаковыми,
 так и разными. Однако для повышения производительности, лучше, чтобы разные объекты возвращали разные коды.
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Эти методы необходимо переопределить в том классе, объекты которого сравниваются.
Не все классы поддерживают эти методы. Также

             !!!!!!!!Как переопределять метод equals в Java!!!!!!!!!!!!!!!!!!!!
@Override
public boolean equals(Object obj) {
/*1. Проверьте*/
if (obj == this) {
/*и верните */ return true;
         }
Проверьте объект на null, а также проверьте, чтобы объекты были одного типа.
 Не делайте проверку с помощью instanceof так как такая проверка будет возвращать true для подклассов и будет работать
  правильно только в случае если ваш класс объявлен как immutable. Вместо этого можно использовать getClass();

if (obj == null || obj.getClass() != this.getClass()) {
            return false;
}
Объявите переменную типа, который вы сравниваете, и приведите obj к этому типу.
 Потом сравнивайте каждый атрибут типа начиная с численных атрибутов (если имеются) потому что численные атрибуты
  проверяются быстрей. Сравнивайте атрибуты с помощью операторов И и ИЛИ (так называемые short-circuit logical operators)
   для объединения проверок с другими атрибутами.

Person guest = (Person) obj;
        return id == guest.id && (firstName == guest.firstName ||
            (firstName != null && firstName.equals(guest.getFirstName())))
                && (lastName == guest.lastName || (lastName != null && lastName .equals(guest.getLastName())));
должно вернуться булево значение.



Распространенные ошибки при переопределении equals в Java
Вместо того, чтобы переопределять метод equals (Override) программист перегружает его (Overload)Синтаксис метода equals()
 в классе Object определен как public boolean equals(Object obj), но многие программисты ненароком перегружают
 метод: public boolean equals(Person obj) - вместо Object в качестве аргумента используют имя своего класса
 (напр. Person). Эту ошибку сложно обнаружить из-за static binding. Таким образом, если вы вызовите этот метод для
 объекта своего класса, то метод не просто скомпилируется, а даже сделает это корректно. Однако, если вы положите ваш
 объект в коллекцию, например ArrayList и вызовите метод contains(), работа которого основана на методе equals(),
  то метод contains не сможет обнаружить ваш объект.!!!!!!!!!!!!!!!!

При переопределении метода equals() не проверять на null переменные, что в конечном итоге заканчивается
NullPointerException при вызове equals(). Ниже представлен корректный код.

firstname == guest.firstname || (firstname != null &&
     firstname.equals(guest.firstname));
Третья распространенная ошибка это не переопределять метод hashCode(), а только equals(). Вы обязаны переопределять
оба метода equals() и hashCode() в Java. Метод hashCode используется в hash -коллекциях(например HashSet), и чем меньше
будет коллизий (одинаковый код при разных объектах) тем эффективнее эти коллекции будут работать с объектами вашего класса.

Последняя распространенная ошибка программистов в том, что при переопределении метода equals() не сохраняется
соответствие между методами equals() и compareTo(), что является неформальным требованием для избежания хранения
 дубликатов в Set (SortedSet, TreeSet).

Подсказки как писать в Java метод equals

Если в классе есть уникальный бизнес-ключ, то будет достаточно сделать проверку только на равенство этих полей.
 Как в нашем примере “id” - уникальный номер для каждого Person.

При переопределении hashCode() в Java удостоверьтесь в использовании всех полей, что были использованы в методе equals().

String и классы-оболочки такие как Integer, Float и Double переопределяют метод equals(),
 но StringBuffer не переопределяет.

При любой возможности делайте поля immutable используя final переменные в Java.

При сравнении String объектов используйте equals() вместо оператора ==.

Два объекта которые логически равны, но загружены из разных ClassLoader не могут быть равными. Помните, что проверка с
 помощью getClass() вернет false если класс-загрузчик разный.

Используйте @Override аннотацию также для метода hashCode, так как это предупреждает неуловимые ошибки, например
возвращаемое значение метода int, однако некоторые программисты возвращают long.


