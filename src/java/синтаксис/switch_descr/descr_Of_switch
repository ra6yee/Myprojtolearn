Switch в Java 12
В Java 12 были улучшены выражения Switch для сопоставления с образцом.

Если использовать Switch как и в примере выше, для задания значения некоторой переменной мы должны были вычислить
значение и присвоить заданной переменной, а затем использовать break:

int count = 2;
int value;
switch (count) {
  case 1:
     value = 12;
     break;
  case 2:
     value = 32;
     break;
  case 3:
     value = 52;
     break;
  default:
     value = 0;
}

Но благодаря возможностям 12-й версии Java мы можем переписать данное выражение следующим образом:

int value = switch (count) {
  case 1:
     break 12;
  case 2:
     break 32;
  case 3:
     break 52;
  default:
     break 0;
};

Давайте немного пройдёмся по измененным моментам:
Если ранее мы задавали переменной значение внутри блоков case, так как сам оператор switch не мог ничего возвращать,
 сейчас такая возможность у нас есть, и мы непосредственно с помощью switch возвращаем значение.

Ранее справа от break у нас уже ничего не могло стоять, а сейчас мы его используем как оператор return для возвращения
 значения нашим switch. Метки с двоеточием отмечают точку входа в блок операторов.
 То есть с того места начинается выполнение всего кода ниже, даже тогда, когда встречается другая метка.

Как итог — сквозной переход от метки к метке, который еще называют проваливанием (fall-through).

Оператор switch в Java - 2Для завершения такого прохода нужно либо полностью пройтись по всем элементам,
либо использовать break или return.

Нововведение в java 12 даёт нам возможность использовать лямбда оператор,  который в свою очередь гарантирует
что будет выполнен только код справа от нее. Без всякого  "проваливания".

Как будем выглядеть предыдущий пример в таком случае:

int count = 2;
int value = switch (count) {
  case 1 -> 12;
  case 2 -> 32;
  case 3 -> 52;
  default -> 0;
};

Код стал значительно проще, не правда ли?

И ещё: лямбда оператор может служить и типичным аналогом двоеточия, после которого идёт целый блок с некоторыми операциями:

int count = 2;
int value = switch (count) {
  case 1 -> {
     //некоторые вычислительные операции...
     break 12;
  }
  case 2 -> {
     //некоторые вычислительные операции...
     break 32;
  }
  case 3 -> {
     //некоторые вычислительные операции...
     break 52;
  }
  default -> {
     //некоторые вычислительные операции...
     break 0;
  }
};

Ну а что если у нас для некоторых кейсов возвращаемое значение будет одинаковым?

Получится, что у нас фактически одинаковые кейсы для некоторых разных значений.
Как бы это можно было бы сократить с помощью новых возможностей Java 12:

int count = 2;
int value = switch (count) {
  case 1, 3, 5 -> 12;
  case 2, 4, 6 -> 52;
  default -> 0;
};
Switch в Java 13
В Java 13 изменился способ возврата значения из switch.

Если в java 12 возвращаемое значение мы писали после break, который служил у нас как return для блока switch,
то сейчас возвращать значение мы будем с помощью слова yield.

Смотрим:

int value = switch (count) {
  case 1:
     yield 12;
  case 2:
     yield 32;
  case 3:
     yield 52;
  default:
     yield 0;
};

В тоже время, код, написанный на java 12 c использованием break для возврата, компилироваться не будет((
Оператор switch в Java - 3Break будет использоваться, но в тех ситуациях, когда нам не нужно ничего возвращать.


Итого
Используйте оператор case при числе ветвлений более двух, чтобы не загромождать if-структурами код.
Не забывайте завершать логический блок каждой ветки соответствующего конкретному значению (блок case) вызовом break.
Оператор switch помимо некоторых примитивных типов, в качестве выражения может использовать также типы Enum и String.
Помните про блок default – употребляйте его для обработки незапланированных значений выбора.
Для оптимизации производительности переместите ветки кода с наиболее часто встречающимися вариантами выбора к началу блока switch.
Не увлекайтесь «оптимизацией» за счёт удаления break в конце блока выбора case – такой код сложен для понимания
 и, как следствие, тяжело сопровождать при его развитии.