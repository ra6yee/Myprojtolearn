Entry – это вложенный интерфейс в интерфейсе Map.

Entry был добавлен, чтобы описать именно пару элементов как одну сущность.

Вот какие методы есть у Map<K,V>:

Методы	                                                                    Описание
int size()	                                                         Возвращает количество пар в map.
boolean isEmpty()	                                                 Проверяет, пустой ли map.
boolean containsKey(Object key)	                                     Содержит ли map заданный ключ?
boolean containsValue(Object value)	                                 Содержит ли map заданное значение?
V get(Object key)	                                                 Возвращает значение по ключу.
V put(K key, V value)	                                             Устанавливает новое значение ключу.
                                                                     Метод возвращает старое значение или null
putAll(Map<? extends K, ? extends V> m)	                             Добавляет пары из другого map.
void clear()	                                                     Очищает map – удаляет все пары.
Set<K>keySet()	                                                     Возвращает Set из ключей.
Collection<V>values()	                                             Возвращает коллекцию из значений.
Set<Map.Entry<K, V>>entrySet()	                                     Возвращает множество (Set) пар.
                    K,V – это типы-параметры для ключей (Key) и значений(Value).


А что еще за Entry такой?

— Это класс, который описывает пару элементов. Методов у него немного:

Методы	                                                        Описание
K getKey()	                                            Возвращает значение «ключа пары».
V getValue()	                                        Возвращает значение «значения пары».
V setValue(V value)	                                    Устанавливает новое значение «значения пары».

Entry удобен тем, что ты можешь взять какую-то пару и передать ее в нужный метод, не передавая туда всю коллекцию map.

— Ясно.

— Ну и пробегусь еще по реализациям Map.

Первая на очереди – это коллекция HashMap. Она использует хэш-таблицы для хранения элементов. Ключи и значения могут
быть любых типов, а также могут быть null. Порядок элементов может меняться при изменении коллекции.

Элементы хранятся внутри HashMap в виде набора групп – корзин (bucket). В какую корзину попадет элемент — зависит от
значения его hashCode().

Очень грубо говоря, элементы со значением хэш-кода от 1 до 100 попадают в первую корзину, со значением от 101 до 200 — во вторую, и т.д.

Смысл такого хранения в том, что при поиске/удалении можно отбрасывать ненужные корзины, и исключать все их элементы из рассмотрения.



Вторая коллекция – это LinkedHashMap. Основное ее отличие от HashMap – она дополнительно хранит элементы в виде связного
списка. У обычной HashMap порядок элементов неопределён и, строго говоря, может меняться со временем. А у LinkedHashMap
можно получить итератор и с помощью него перебрать все элементы в порядке их добавления в LinkedHashMap. Так же у
LinkedHashMap есть итератор, который позволяет обойти все пары в порядке из последнего использования/активности.



Третья коллекция, о которой я бы хотела сегодня рассказать – это TreeMap.

TreeMap хранит свои элементы отсортированными по возрастанию. Это достигается благодаря тому, что TreeMap для их
хранения использует сбалансированное красно-черное бинарное дерево.

Благодаря этому там очень низкое время вставки и поиска элементов. Этот класс – отличный выбор при использовании очень
 больших объемов данных.



— WeakHashMap, но мне Риша рассказывал про него пару дней назад.

— Это когда?

— Ну, когда рассказывала про SoftReference, WeakReference и PhantomReference.