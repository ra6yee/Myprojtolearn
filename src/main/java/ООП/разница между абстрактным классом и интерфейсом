Интерфейс описывает только поведение. У него нет состояния.
А у абстрактного класса состояние есть: он описывает и то, и другое.

Возьмем для примера абстрактный класс Bird и интерфейс Flyable:

public abstract class Bird {
   private String species;
   private int age;

   public abstract void fly();

   public String getSpecies() {
       return species;
   }

   public void setSpecies(String species) {
       this.species = species;
   }

   public int getAge() {
       return age;
   }

   public void setAge(int age) {
       this.age = age;
   }
}
Давай создадим класс птицы Mockingjay (сойка-пересмешница) и унаследуем его от Bird:

public class Mockingjay extends Bird {

   @Override
   public void fly() {
       System.out.println("Лети, птичка!");
   }

   public static void main(String[] args) {

       Mockingjay someBird = new Mockingjay();
       someBird.setAge(19);
       System.out.println(someBird.getAge());
   }
}
Как видишь, мы легко получаем доступ к состоянию абстрактного класса — к его переменным species (вид) и age (возраст).

Но если мы попытаемся сделать это же с интерфейсом, картина будет другой. Можем попробовать добавить в него переменные:

public interface Flyable {

   String species = new String();
   int age = 10;

   public void fly();
}

public interface Flyable {

   private String species = new String(); // ошибка
   private int age = 10; // тоже ошибка

   public void fly();
}
У нас даже не получится создать внутри интерфейса private-переменные. Почему? Потому что private-модификатор создали,
чтобы скрывать реализацию от пользователя. А внутри интерфейса реализации нет: там и скрывать нечего.

Интерфейс только описывает поведение. Соответственно, мы не сможем реализовать внутри интерфейса геттеры и сеттеры.
Такова природа интерфейса: он нужен для работы с поведением, а не состоянием.

В Java8 появились дефолтные методы интерфейсов, у которых есть реализация. О них ты уже знаешь, поэтому повторяться не будем.

Абстрактный класс связывает между собой и объединяет классы, имеющие очень близкую связь.
В то же время, один и тот же интерфейс могут реализовать классы, у которых вообще нет ничего общего.

Вернемся к нашему примеру с птицами.

Наш абстрактный класс Bird нужен, чтобы на его основе создавать птиц. Только птиц и никого больше! Конечно, они будут разными.

Разница между абстрактными классами и интерфейсами - 2
С интерфейсом Flyable все обстоит по-другому. Он только описывает поведение, соответствующее его названию, — «летающий».
 Под определение «летающий», «способный летать» попадает много объектов, не связанных между собой.

Разница между абстрактными классами и интерфейсами - 3
Эти 4 сущности между собой никак не связаны. Что уж там говорить, не все из них даже являются одушевленными.
Тем не менее, все они — Flyable, способные летать.

Мы бы не смогли описать их с помощью абстрактного класса. У них нет общего состояния, одинаковых полей.
Чтобы дать характеристику самолету, нам, наверное, понадобятся поля «модель»,
«год выпуска» и «максимальное количество пассажиров».
Для Карлсона — поля для всех сладостей, которые он сегодня съел, и список игр, в которые он будет играть с Малышом.
Для комара...э-э-э...даже не знаем… Может, «уровень надоедливости»? :)

Главное, что с помощью абстрактного класса описать их мы не можем.
Они слишком разные. Но есть общее поведение: они могут летать.
Интерфейс идеально подойдет для описания всего на свете, что умеет летать, плавать, прыгать или обладает каким-то другим поведением.

Классы могут реализовывать сколько угодно интерфейсов, но наследоваться можно только от одного класса.

Об этом мы уже говорили не раз. Множественного наследования в Java нет, а множественная реализация есть.
Отчасти этот пункт вытекает из предыдущего: интерфейс связывает между собой множество разных классов,
у которых часто нет ничего общего, а абстрактный класс создается для группы очень близких друг другу классов.
Поэтому логично, что наследоваться можно только от одного такого класса. Абстрактный класс описывает отношения «is a».

