Почему классы называют «абстрактными»
Ты наверняка помнишь, что такое «абстракция» — мы это уже проходили :)
Если вдруг подзабыл — не страшно, вспомним: это принцип ООП, согласно которому при проектировании классов и создании
объектов необходимо выделять только главные свойства сущности, и отбрасывать второстепенные.

Например, если будем проектировать класс SchoolTeacher — школьный учитель — вряд ли понадобится характеристика «рост».
 Действительно: для преподавателя эта характеристика не важна.
 Но вот если мы будем создавать в программе класс BasketballPlayer — игрок в баскетбол — рост станет одной из главных характеристик.

Так вот, абстрактный класс — это максимально абстрактная, о-о-о-чень приблизительная «заготовка» для группы будущих классов.
Эту заготовку нельзя использовать в готовом виде — слишком «сырая».
Но она описывает некое общее состояние и поведение, которым будут обладать будущие классы — наследники абстрактного класса.

Рассмотрим простой пример с машинами:

public abstract class Car {

   private String model;
   private String color;
   private int maxSpeed;

   public abstract void gas();

   public abstract void brake();

   public String getModel() {
       return model;
   }

   public void setModel(String model) {
       this.model = model;
   }

   public String getColor() {
       return color;
   }

   public void setColor(String color) {
       this.color = color;
   }

   public int getMaxSpeed() {
       return maxSpeed;
   }

   public void setMaxSpeed(int maxSpeed) {
       this.maxSpeed = maxSpeed;
   }
}
Вот так выглядит самый простой абстрактный класс. Как видишь, ничего особенного :)

Для чего он может нам понадобиться?

Прежде всего, он максимально абстрактно описывает нужную нам сущность — автомобиль.
Слово abstract находится здесь недаром. В мире не существует «просто машин».
 Есть грузовики, гоночные автомобили, седаны, купе, внедорожники.

Наш абстрактный класс — это просто «чертеж», по которому мы позже будем создавать классы-автомобили.

public class Sedan extends Car {

   @Override
   public void gas() {
       System.out.println("Седан газует!");
   }

   @Override
   public void brake() {
       System.out.println("Седан тормозит!");
   }

}

Это во многом похоже на то, о чем мы говорили в лекциях про наследование.
 Только там у нас класс Car и его методы не были абстрактными.
 Но у такого решения есть целый ряд минусов, которые в абстрактных классах исправлены.

Первое и главное — экземпляр абстрактного класса создать нельзя:

public class Main {

   public static void main(String[] args) {

       Car car = new Car(); // Ошибка! Класс Car является абстрактным!
   }
Эта «фишка» была реализована создателями Java специально.
Еще раз, для запоминания: абстрактный класс — это просто чертеж для будущих «нормальных» классов.
Тебе же не нужны экземпляры чертежа, правильно? Вот и экземпляры абстрактного класса создавать не надо :)

А если бы класс Car не был абстрактным, мы легко могли бы создавать его объекты:
Абстрактные классы избавляют нас от «просто объектов». Они дают нам базовое состояние и поведение.
Например, у всех машин должна быть модель, цвет и максимальная скорость, а еще они должны уметь газовать и тормозить. Вот и все.
Это — общая абстрактная схема, дальше ты уже сам проектируешь нужные тебе классы.

Обрати внимание: два метода в абстрактном классе тоже обозначены как abstract, и они вообще не реализованы.
 Причина та же: абстрактные классы не создают «поведения по умолчанию» для «просто машин».
 Они просто говорят, что должны уметь делать все машины.

Впрочем, если поведение по умолчанию тебе все-таки нужно, методы в абстрактном классе можно реализовать.
 Java этого не запрещает:

public abstract class Car {

   private String model;
   private String color;
   private int maxSpeed;

   public void gas() {
       System.out.println("Газуем!");
   }

   public abstract void brake();

   //геттеры и сеттеры
}


public class Sedan extends Car {

   @Override
   public void brake() {
       System.out.println("Седан тормозит!");
   }

}

public class Main {

   public static void main(String[] args) {

       Sedan sedan = new Sedan();
       sedan.gas();
   }
}
Как видишь, мы реализовали в абстрактном классе один метод, а второй не стали.

В итоге поведение нашего класса Sedan разделилось на две части: если вызвать у него метод gas(),
 он «подтянется» из родительского абстрактного класса Car, а метод brake() мы переопределили в классе Sedan.
Получилось очень удобно и гибко.

Но теперь наш класс не такой уж и абстрактный? Ведь у него, по факту, половина методов реализована.

На самом деле — и это очень важная особенность — класс является абстрактным, если хотя бы один из его методов является
абстрактным. Хоть один из двух, хоть один из тысячи методов — без разницы.

Мы можем даже реализовать все методы и не оставить ни одного абстрактного.
 Будет абстрактный класс без абстрактных методов.
  В принципе, это возможно, и компилятор не выдаст ошибок, но лучше так не делать: слово abstract потеряет смысл,
  а твои коллеги-программисты сильно удивятся, увидев такое :/

При этом, если метод помечен словом abstract, каждый класс-наследник должен его реализовать или быть объявленным как
абстрактный. Иначе компилятор выбросит ошибку.

Разумеется, каждый класс может наследоваться только от одного абстрактного класса, так что в плане наследования разницы
между абстрактными и обычными классами нет.
 Неважно, наследуемся мы от абстрактного класса или от обычного, класс-родитель может быть только один.





