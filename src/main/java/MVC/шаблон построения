MVC расшифровывается как Model—View—Controller. Это принцип построения архитектуры большого приложения, при котором оно
 разбивается на три части.

                                              Model

Первая часть содержит всю бизнес-логику приложения. Такая часть называется Модель (Model). В ней содержится код, который
 делает все то, для чего приложение создавалось. Эта часть наиболее независимая от остальных.

                                              View

Вторая часть содержит все, что касается отображения данных пользователю. Такая часть называется Вид (View). Именно в ней
 содержится код, который управляет показом окон, страниц, сообщений и т.д.

                                            Controller

Третья часть содержит код, который занимается обработкой действий пользователя. Любые действия пользователя,
направленные на изменения модели, должны обрабатываться тут. Такая часть называется Controller.


Такой подход позволяет независимо делать три вещи: логику программы (Model), механизм показа всех данных программы
пользователю (View), обрабатывать ввод/действия пользователя (Controller).
Очень часто у приложения бывает несколько View. Это нормально.


— С точки зрения Java-программиста, можно сказать, что Model, View, Controller – это три группы классов, у которых:

а) у каждой части есть свое назначение;

б) связи между классами одной группы довольно сильные;

в) связи между группами довольно слабые;

г) способы взаимодействия частей довольно сильно регламентированы.

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Модель – это самая независимая часть системы. Она не зависит от View & Controller. Модель не может использовать классы
 из разделов View & Controller(!).

Основное ограничение вида (View) – вид не может менять модель. Классы вида могут обращаться к модели за данными или
подписываться на события, но менять модель классы View не могут.

Основное ограничение контроллера – он не занимается отображением данных. Контроллер обрабатывает действия пользователя
и меняет в соответствии с ними модель.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

Модель (Model) предоставляет данные и реагирует на команды контроллера, изменяя своё состояние[1].
Представление (View) отвечает за отображение данных модели пользователю, реагируя на изменения модели[1].
Контроллер (Controller) интерпретирует действия пользователя, оповещая модель о необходимости изменений[1].


Модель
Модель предоставляет данные и методы работы с ними: запросы в базу данных, проверка на корректность. Модель не зависит
от представления (не знает как данные визуализировать) и контроллера (не имеет точек взаимодействия с пользователем),
просто предоставляя доступ к данным и управлению ими.

Модель строится таким образом, чтобы отвечать на запросы, изменяя своё состояние, при этом может быть встроено
уведомление «наблюдателей».

Модель, за счёт независимости от визуального представления, может иметь несколько различных представлений для одной
«модели»

Представление
Представление отвечает за получение необходимых данных из модели и отправляет их пользователю. Представление не
обрабатывает введённые данные пользователя [10].

Контроллер
Контроллер обеспечивает «связь» между пользователем и системой. Контролирует и направляет данные от пользователя к
системе и наоборот. Использует модель и представление для реализации необходимого действия.

Функциональные возможности и расхождения
Поскольку MVC не имеет строгой реализации, то реализован он может быть по-разному. Нет общепринятого определения, где
должна располагаться бизнес-логика. Она может находиться как в контроллере, так и в модели. В последнем случае, модель будет содержать все бизнес-объекты со всеми данными и функциями.

Некоторые фреймворки жёстко задают где должна располагаться бизнес-логика, другие не имеют таких правил.

Также не указано, где должна находиться проверка введённых пользователем данных. Простая валидация может встречаться
даже в представлении, но чаще они встречаются в контроллере или модели.

Интернационализация и форматирование данных также не имеет четких указаний по расположению.




Начинающие программисты очень часто трактуют архитектурную модель MVC как пассивную модель MVC: модель выступает
исключительно совокупностью функций для доступа к данным, а контроллер содержит бизнес-логику. В результате — код
моделей по факту является средством получения данных из СУБД, а контроллер — типичным модулем, наполненным
бизнес-логикой. В результате такого понимания — MVC-разработчики стали писать код, который Pádraic Brady (известный в
кругах сообщества «Zend Framework») охарактеризовал как «ТТУК» («Толстые, тупые, уродливые контроллеры»;
Fat Stupid Ugly Controllers):

Среднестатистический ТТУК получал данные из БД (используя уровень абстракции базы данных, делая вид, что это модель)
или манипулировал, проверял, записывал, а также передавал данные в Представление. Такой подход стал очень популярен
потому, что использование таких контроллеров похоже на классическую практику использования отдельного php-файла для
каждой страницы приложения.

— [http://blog.astrumfutura.com/2008/12/the-m-in-mvc-why-models-are-misunderstood-and-unappreciated/ The M in MVC: Why
Models are Misunderstood and Unappreciated
Но в объектно-ориентированном программировании используется активная модель[12] MVC, где модель — это не только
совокупность кода доступа к данным и СУБД, но и вся бизнес-логика; также модели могут инкапсулировать в себе другие
модели. Контроллеры же, — как элементы информационной системы, — ответственны лишь за:

приём запроса от пользователя;
анализ запроса;
выбор следующего действия системы, соответственно результатам анализа (например, передача запроса другим элементам
системы).
Только в этом случае контроллер становится «тонким» и выполняет исключительно функцию связующего звена (glue layer)
между отдельными компонентами информационной системы.












