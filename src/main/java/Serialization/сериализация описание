Это сохранение объекта в файл на диске. Десериализация это восстановление, считывание объекта из файла.Все достаточно
просто.
— Молодец, Амиго. Приятно слышать, что ты замечаешь такие мелочи. А ты бы смог дописать код, чтобы было сохранение в
 файл и чтение из файла?

— А что там писать?! Объявил FileInputStream и FileOutputStream и передавай их в методы save & load. Тут уже ничего не
 перепутаешь — все просто.

— Рада за тебя. Итак, новая тема – сериализация.

Serialization – это практически то же самое, что мы с тобой только что делали, только гораздо круче и встроено прямо в
 Java-машину. Java-машина умеет сохранять и загружать свои объекты. Для этого ей даже не требуются методы save & load:
 все объекты хранятся внутри Java-машины, и она имеет к ним полный доступ.

Мы просто берем объект и сохраняем его в поток/читаем из потока:

public static void src.main(String[] args) throws Exception
{
 Cat cat = new Cat();

 //save cat to file
 FileOutputStream fileOutput = new FileOutputStream("cat.dat");
 ObjectOutputStream outputStream = new ObjectOutputStream(fileOutput);
 outputStream.writeObject(cat);
 fileOutput.close();
 outputStream.close();

 //load cat from file
 FileInputStream fiStream = new FileInputStream("cat.dat");
 ObjectInputStream objectStream = new ObjectInputStream(fiStream);
 Object object = objectStream.readObject();
 fiStream.close();
 objectStream.close();

 Cat newCat = (Cat)object;
}

Итак, что еще тебе нужно знать?

Во-первых, при сериализации (неважно, используешь ты Serializable или Externalizable) обращай внимание на
переменные static.

При использовании Serializable эти поля вообще не сериализуются (и, соответственно, их значение не меняется,
 т.к. static поля принадлежат классу, а не объекту). А вот при использовании Externalizable ты управляешь процессом сам,
  поэтому технически сделать это можно. Но не рекомендуется, так как это чревато трудноуловимыми ошибками.

Во-вторых, внимание стоит также обратить на переменные с модификатором final. При использовании Serializable они
сериализуются и десериализуются как обычно, а вот при использовании Externalizable десериализовать
final-переменную невозможно!

Причина проста: все final-поля инициализируются при вызове конструктора по умолчанию, и после этого их значение уже
невозможно изменить. Поэтому для сериализации объектов, содержащих final-поля, используй стандартную сериализацию через
Serializable.

В-третьих, при использовании наследования, все классы-наследники, происходящие от какого-то Externalizable-класса, тоже
 должны иметь конструкторы по умолчанию.



 При сериализации объекта сериализуются все объекты, на которые он ссылается в своих переменных экземпляра. И если те
 объекты тоже ссылаются на третьи объекты, они тоже сериализуются.
  И так до бесконечности. Все классы в этой цепочке должны быть Serializable, иначе их невозможно будет сериализовать
  и будет выброшено исключение.

1) Объект нестатического внутреннего класса не может существовать без объекта внешнего класса, а значит при сериализации
 объекта класса В сериализуется и связанный с ним объект класса Solution. Соответственно, для сериализации объекта
  класса В нужно, чтобы Solution был также Serializable.

2) При десериализации "по умолчанию" (равно как и методом defaultReadObject) выполняется конструктор без параметров
 первого (в иерархии наследования) несериализованного родительского класса. Т.е. если у класса А нет конструктора без
 параметров, то будет ошибка.

3) При десериализации объекта класса В выполняется конструктор без параметров класса А, который (даже если он пустой)
 инициализирует переменные класса. В результате в переменной name будет "А" вместо "АВ2В2". Соответственно поле name
 приходиться сериализовать вручную.

 1)Если вложенный класс не статический и Serializable, то класс, в котором он находится, тоже должен быть Serializable
 2)Если класс Serializable, а класс-родитель - нет, то у класса-родителя должен быть конструктор без параметров
 3)Все, что нестандартное, как например в нашем случае переменная типа String родительского класса
 (который не Serializable), нужно сериализовать вручную. Для этого нужно в класс, который сериализируется, добавить два
 приватных метода writeObject(ObjectOutputStream out) и readObject(ObjectInputStream in), в которых прописать наш
  порядок нестандартной сериализации (порядок чтения должен соответствовать порядку записи)
И методы должны быть строго приватными!!!!


