Serialization объектов Singleton

В чем проблема сериализации Singleton-ов? А проблема в уже упомянутом мной факте – после десериализации мы получим
 другой объект. Это видно в результатах  ссылки на исходный и десериализованный
  объекты не совпадают. Таким образом, сериализация дает возможность создать Singleton еще раз, что нам совсем не нужно.
   Можно, конечно, запретить сериализовать Singleton-ы, но это, фактически, уход от проблемы, а не ее решение.

Решение же заключается в следующем. В классе определяется метод со следующей сигнатурой

любой модификатор Object readResolve() throws ObjectStreamException
Модификатор доступа может быть private, protected и по умолчанию (default). Можно, наверное, сделать его и public, но
смысла я в этом не вижу. Назначение этого метода – возвращать замещающий объект вместо объекта, на котором он вызван.
Приведу простой пример:

public class Answer implements Serializable{

    private static final String STR_YES = "Yes";
    private static final String STR_NO = "No";

    public static final Answer YES = new Answer(STR_YES);
    public static final Answer NO = new Answer(STR_NO);

    private String answer = null;

    private Answer(String answer){
        this.answer = answer;
    }

    private Object readResolve() throws ObjectStreamException{
        if (STR_YES.equals(answer))
            return YES;
        if (STR_NO.equals(answer))
            return NO;
        throw new InvalidObjectException("Unknown value: " + answer);
    }
}
Класс, приведенный выше – простейший перечислимый тип. Всего два значения – Answer.YES и Answer.NO. Соответственно
 именно эти два значения и должны фигурировать после десериализации. Что делается в методе readResolve?
  Он вызывается на десериализованном объекте. И возвращать он должен уже существующий экземпляр класса, соответствующий
  внутреннему состоянию десериализованного объекта. В данном примере – проверяется значение поля answer. Если объект,
   соответствующий внутреннему состоянию, не найден... На мой взгляд, это зависит от ситуации.
В приведенном примере стоит инициировать исключение. Возможно, в каких-то ситуациях будет полезно вернуть this.
Примером этого, например, является реализация java.util.logging.Level.

Существует и обратный метод – writeReplace, который, как вы, наверное, уже догадались, позволяет выдать замещающий
объект вместо текущего, для сериализации. Мне, честно сказать, трудно представить себе ситуации, в которых это может
 понадобиться. Хотя в недрах кода Sun он как-то используется.

Оба метода, как readResolve, так и writeReplace, вызываются при использовании стандартных средств сериализации
 (методов readObject и writeObject), вне зависимости от того, объявлен ли сериализуемый класс как Serializable или Externalizable.

Самое интересное, что, похоже, из этих методов можно возвращать не только экземпляр класса, в котором этот метод
определен, но и экземпляр другого класса. Я видел подобные примеры в глубинах библиотек Sun, во всяком случае,
для writeReplace – точно видел. Но по каким принципам можно это делать – не берусь пока судить. Вообще, советую
интересующимся просмотреть исходники J2SE 5.0, причем полные. Они доступны по лицензии JRL. Там есть много интересных
примеров использования этих методов. Исходники можно взять тут – http://java.sun.com/j2se/jrl_download.html. Правда,
 требуется регистрация, но она, естественно, бесплатна.

Отдельно хочу коснуться сериализации перечислений (enum), появившихся в Java 5.0. Поскольку при сериализации в поток
пишется имя элемента и его порядковый номер в определении в классе, можно было бы ожидать проблем при десериализации
в случае изменения порядкового номера (что может случиться очень легко – достаточно поменять элементы местами). Однако,
 к счастью, таких проблем нет. Десериализация объектов типа enum контролируется для обеспечения соответствия
  десериализуемых экземпляров уже имеющимся у виртуальной машины. Фактически, это то, что делает обычно метод
  readResolve, но реализовано где-то существенно глубже. Сопоставление объектов осуществляется по имени.
  Разработчикам версии 5.0 – респект!