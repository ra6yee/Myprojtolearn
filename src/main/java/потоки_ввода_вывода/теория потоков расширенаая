Поток ввода (Input) — данные поступают из потока в нашу программу. Мы их читаем из этого потока
Поток вывода (Output) — данные поступают в поток из нашей программы. Мы их пишем в этот поток

Вторым критерием разделения может служить ТИП передаваемых данных.
Да-да, байты не всегда являются удобным вариантом передачи — есть еще текст. Символы.
Я надеюсь, вы помните, что символ в Java занимает ДВА байта.
Так вот передача двух байтов как одного целого числа имеет сложность — какой байт должен идти первым ?

InputStream — поток для чтения байтов (поток ввода)
Reader — поток для чтения символов (поток ввода)
OutputStream — поток для записи байтов (поток вывода)
Writer — поток для записи символов (поток вывода)

 Разница для InputStream и Reader состоит только в том, что первый читает байты (byte), а второй — символы (char).
Вполне логично вытекает название основного метода для классов OutputStream и Writer — метод write.
 Тоже в нескольких модификациях.

Схема работы с потоком в упрощенном виде выглядит так:

Создается экземпляр потока
Поток открывается (для чтения или записи)
Производится чтение из потока/запись в поток
Поток закрывается
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
 запишем строку в файл. В текстовый файл.
 Т.е. Нам потребуется поток для символов — Writer. Потом мы прочитаем этот файл — и для этого используем Reader.

Reader и Writer — абстрактные классы.
 Для работы с файлами нам потребуются уже конкретные и это будут FileReader и FileWriter.

import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;

public class WriterReader  // записываем в файл!!!
{
    public static void main(String[] args) {
        writeText();        // метод записи

          readText();      // метод чтения
    }

    private static void writeText() {
        String test = "TEST !!!"; // Эту строку мы посимвольно запишем в файл

        // Создание файлового потока для записи символов ак автозакрываемый ресурс
        // Нам не надо вызывать fw.close(), т.к. в данном случае он будет закрыт автоматически
        try (FileWriter fw = new FileWriter("text.txt")) {
            // Записываем посимвольно , обращаясь к каждому элементу строку (как к символу)
            for (int i = 0; i < test.length(); i++) {
                fw.write(test.charAt(i));
            }
        } catch (IOException ex) {
            ex.printStackTrace(System.out);
        }
    }

    private static void readText() {
        try (FileReader fr = new FileReader("text.txt")) {
            // Переменная для хранения строки
            StringBuilder sb = new StringBuilder();
            int code = -1;
            // Читаем посимвольно пока код считанного символа не станет равным -1
            while ((code = fr.read()) != -1) { // метод read без параметров возвращает не символ — он возвращает int. Это КОД символа.
                // Вызов Character.toChars() преобразует int в char
                sb.append(Character.toChars(code));
            }
            System.out.println(sb.toString());

        } catch (IOException ex) {
            ex.printStackTrace(System.out);
        }
    }
}


Если вы в смущении от конструкции while ((code = fr.read()) != -1),
то ее надо читать так — сначала мы считываем символ из входного потока — (code = fr.read()).
 Теперь внутри скобок у нас по сути есть результат этой операции, которая находится в переменной code.
 И уже потом содержимое скобок мы сравниваем с “-1”.
Если это не так, значит мы считали символ и можем его прибавить к нашей строке.

!!!!!!!!!!!!!!!!!Копирование двоичного файла!!!!!!!!!!!!!!!!!!!!!!!
Как я уже указывал выше, для чтения и записи байтовых потоков используются InputStream и OutputStream соответственно.
Для работы с файлами существуют два специализированных класса FileInputStream и FileOutputStream.
У обоих есть методы read и write, которые считывают и пишут байт.

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class CopyFile          // это медленная программа, она не использует буфер.следующая программа будет с буфером.
{
    public static void main(String[] args) {
        copyFile("С:/temp/first.txt", "C:/temp/second.txt");
    }

    private static void copyFile(String source, String target) {

        try (FileInputStream fis = new FileInputStream(source);
             FileOutputStream fos = new FileOutputStream(target)) {

            int data;
            while ( (data = fis.read()) != -1) { тут тоже самое , как только файл закончится, fis вернет минус один
                fos.write(data);
            }

        } catch (IOException ex) {
            ex.printStackTrace(System.out);
        }
    }
}
В общем, все достаточно просто — мы открыли два потока — один на чтение, другой на запись.
(FileInputStream и FileOutputStream).
 И потом в цикле мы читаем в переменную data байт из входного потока,
 проверяем, что нам вернулся не “-1” (признак окончания) и пишем уже в выходной поток.
(причем тип переменной должен быть int). Опять же- закрытие наших файлов происходит автоматически.

При небольших размерах файлов все работает вполне прилично.
Но если вы попробуете скопировать файл хотя бы в несколько мегабайт
 то запаситесь терпением — это может происходить крайне долго. В чем же причина ?
  Все весьма просто — вы читаете по ОДНОМУ байту. Это крайне неэффективно.
  На самом деле для чтения каждого байта вы считываете достаточно приличный кусок данных с диска,
  но используете только один байт.
И так много-много раз. Производительность ужасающая, загрузка дисковой подсистемы сумасшедшая.
 В общем — все плохо.

На помощь придет буферизованные версии чтения/записи. Т.е. Вы считываете сразу несколько килобайт за один раз.
Это радикально повышает производительность.
Для этого надо использовать другой вариант вызова методов read и write — он принимает в качестве входного параметра массив байтов.
Т.е. при чтении поток сразу заполняет весь массив (или его часть) и делает операцию сразу для большого количества — читает или пишет.
На что следует обратить внимание в этом случае — при операции чтения вам возвращается количество реально считанных байт
 (если оно равно “-1”, значит поток закончился), а операция записи может писать не весь массив,
 а только какую-то его часть. Вы указываете индекс начального элемента массива и количество.
 Теперь смотрим код.
  И не бойтесь подставить файл размером несколько сотен мегабайт — копирование работает достаточно быстро.

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class CopyFile
{
    public static void main(String[] args) {
        copyFile("C:/temp/first_big.dat", "C:/temp/second_big.dat");
    }

    private static void copyFile(String source, String target) {

        try (FileInputStream fis = new FileInputStream(source);
             FileOutputStream fos = new FileOutputStream(target)) {

            byte[] buffer = new byte[8192];   // размер буфера 8 Кб
            int size = 0;
            while ( (size = fis.read(buffer)) != -1) {
                fos.write(buffer, 0, size);
            }

        } catch (IOException ex) {
            ex.printStackTrace(System.out);
        }
    }
}

Здесь можно видеть, что в переменную buffer мы считываем байты, а в переменной size сохраняем количество реально считанных байт.
 Вы скорее всего задумывались над ситуацией, когда под конец файла размер буфера может быть больше, чем количество прочитанных байтов.
 После этого при записи (метод fos.write(buffer, 0, size)) мы используем массив и количество считанных байт.
 Начальный элемент — это первый элемент в массиве (индекс 0).

!!!!!!!!!!!!!!!!!!!!!!!Сейчас мы воспользуемся той идеей, о которой я говорил чуть выше. А именно о возможности соединять потоки друг с другом.!!!!!!!!!!!!

Давайте проанализируем шаги, которые нам надо выполнить при чтении текстового файла построчно.
Еще раз — мы хотим читать текстовый файл в определенной кодировке по строкам.
Думаю, что сейчас вы еще не готовы думать в парадигме потоков, поэтому возьму на себя роль проводника. Пойдем по шагам.

Первое — нам надо читать байты из файла. Почему так ?
Потому что я выше говорил — каждый символ может быть представлен по-разному, в зависимости от кодировки.
Вряд ли кодировщику удобно самому читать байты из файла — ему проще работать с уже готовым потоком (массивом) байт.
И этот поток надо ему обеспечить. Значит нам нужен байтовый поток ввода из файла. И мы его знаем — FileInputStream
Второе — готовый поток байт нам надо превратить в поток символов Unicode.
И тут наступает время другого потока — InputStreamReader.
Он принимает на вход поток байт и кодировщик, с помощью которого он преобразует поток байт в поток символов
Третье — уже готовый поток символов надо делить на отдельные строки.
И для этой востребованной функциональности тоже есть уже готовый поток — BufferedReader.
На вход он получает поток символов, а на выходе позволяет читать его по строчкам
В итоге, мы получаем, что нам надо соединить три потока вместе.
Первый читает байты из файла, второй — преобразует их в символы, третий делит символы на строки.
Похоже, что пришла пора смотреть код, который позволяет это сделать.
Первой строкой задается имя файла — посмотрите, чтобы он существовал и не был большим — пусть там будет несколько строк.
Результатом работы будет два варианта строк из одного и того же файла в разных кодировках — UTF-8 и Windows-1251.
Один из них (а возможно и оба — если кодировка файла совсем другая) выведет вам полную ерунду.

import java.io.BufferedReader;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.Charset;

public class EncodeRedaer
{
    public static void main(String[] args) {
        final String fileName = "C:/temp/test.txt";    // Подставить имя текстового файла

        readFile(fileName, "UTF-8");          // Читаем в кодировке UTF-8
        System.out.println();
        readFile(fileName, "windows-1251");   // Читаем в кодировке Windows-1251
    }

    private static void readFile(String fileName, String charset) {  соединили так соединили
        try (FileInputStream fis = new FileInputStream(fileName);
             InputStreamReader isr = new InputStreamReader(fis, Charset.forName(charset));
             BufferedReader br = new BufferedReader(isr)) {

            String line;
            while ((line = br.readLine()) != null) {
                System.out.println(line);
            }

        } catch (IOException ex) {
            ex.printStackTrace(System.out);
        }
    }
}

BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(fileName), Charset.forName(charset)))
значит собираем потоки с конца:
BufferedReader      соединяет символы в строки !!!метод реадлайн!!!
InputStreamReader   преобразовывает байты в символы в указанной кодировке
FileInputStream     читает байты из файла

в общем то, достаточно удобно




