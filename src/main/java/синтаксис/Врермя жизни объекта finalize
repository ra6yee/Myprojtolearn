Каждый объект после создания существует (живёт) пока хотя бы одна переменная хранит его адрес
 (на него есть хотя бы одна ссылка). Если ссылок больше не остаётся – объект умирает.
  Примеры:

public class MainClass
{
   public static void main (String[] args)
   {
    ┏ Tommy
    ┃ Cat cat = new Cat("Tommy");
    ┃ cat = null;                            — Объект «кот Томми» существует всего одну строчку с момента создания.
                                                                   Уже на следующей строке единственную переменную,
                                           которая хранит на него ссылку, «обнуляют» и объект уничтожается Java-машиной.
    ┗
    ┏ Sammy
    ┃ Cat cat1 = new Cat("Sammy");
    ┃┏ Maisy
    ┃┃Cat cat2 = new Cat("Maisy");
    ┃┃cat2 = cat1;          тут майси умер
    ┃┗
    ┃┏ Ginger
    ┃┃cat1 = new Cat("Ginger");
    ┃┃ cat2 = null;       тут умер семми
    ┃┗
    ┗
   }
}
— Объект «кот Томми» существует всего одну строчку с момента создания.
Уже на следующей строке единственную переменную,
 которая хранит на него ссылку, «обнуляют» и объект уничтожается Java-машиной.
— Объект «кот Семми» после создания хранится в переменной cat1.
Или, если быть точным, там хранится ссылка на него.
 Парой строчек ниже эта ссылка копируется в cat2.
 После этого в cat1 сохраняется ссылка на другой объект, и ссылка на «кот Семми» остаётся только в cat2.
  Наконец, в последней строке метода main, последнюю ссылку на объект обнуляют.
— Объект «кот Мейси» существует сразу после создания всего одну строчку.
 На следующей строке переменной cat2 присваивают другое значение, и ссылка на «кот Мейси» теряется.
 Объект становится недостижимым и считается мусором (объект умер).
— Объект «кот Джинджер» существует сразу после создания и до конца метода.
Вместе с окончанием метода будет уничтожена переменная cat1, и следом за ней и объект «кот Джиндже


В момент, когда сборщик мусора добрался до объекта, перед самым его уничтожением,
 у объекта вызывается специальный метод — finalize().

Его можно использовать, чтобы освободить какие-то дополнительные ресурсы, которые использовал объект.

Метод finalize() принадлежит классу Object.
То есть, наравне с equals(), hashCode() и toString(), с которыми ты уже познакомился ранее, он есть у любого объекта.
Например, давай попробуем ради эксперимента запустить такой код:

public class Cat {

   private String name;

   public Cat(String name) {
       this.name = name;
   }

   public Cat() {
   }

   public static void main(String[] args) throws Throwable {

       for (int i = 0 ; i < 1000000; i++) {

           Cat cat = new Cat();
           cat = null;//вот здесь первый объект становится доступен сборщику мусора
       }
   }

   @Override
   protected void finalize() throws Throwable {
       System.out.println("Объект Cat уничтожен!");
   }
}

Мы создаем объект Cat и уже в следующей строчке кода обнуляем единственную ссылку на него. И так — миллион раз.

Мы явно переопределили метод finalize(), и он должен миллион раз вывести строку в консоль,
каждый раз перед уничтожением объекта Cat.

Но нет! Если быть точным, на моем компьютере он отработал всего 37346 раз!
 То есть только в 1 случае из 27-ми установленная у меня Java-машина принимала решение
  вызвать метод finalize() — в остальных случаях сборка мусора проходила без этого.
Поэтому небольшой совет на будущее: не стоит полагаться на метод finalize() в случае с
 освобождением каких-то критически важных ресурсов.
  Может JVM его вызовет, а может нет. Кто знает?
   Если твой объект при жизни занимал какие-то суперважные для производительности ресурсы,
    например, держал открытым соединение с базой данных, лучше создай в своем классе специальный метод
     для их освобождения и вызови его явно, когда объект уже будет не нужен.
      Так ты точно будешь знать, что производительность твоей программы не пострадает.

По такому же принципу работает и сборщик мусора.
 Если в программе будет оставаться много объектов,
  которые он не может собрать (как носок или Lego для робота-пылесоса),
   в один прекрасный момент память закончится. И зависнет не только написанная тобой программа,
   но и все остальные программы, запущенные в этот момент на компьютере. Для них тоже не будет хватать памяти.

   кратенькое знакомство с методом finalize().
   Этот метод вызывается Java-машиной у объекта перед тем, как объект будет уничтожен.
    Фактически этот метод – противоположность конструктору. В нем можно освобождать ресурсы, используемые объектом.

   — Этот метод есть у класса Object и, следовательно, есть в каждом классе
   (все классы в Java считаются унаследованными от класса Object и содержат копию его методов).
   Ты можешь просто написать в твоём классе такой же метод, и он
   будет вызываться перед уничтожением объектов этого класса.

   Пример:

   Пример:
   class Cat
   {
       String name;

       Cat(String name)
       {
           this.name = name;
       }

       protected void finalize() throws Throwable
       {
           System.out.println(name + " destroyed");
       }
   }


class Cat4 {
    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("A Cat was destroyed");
    }
}