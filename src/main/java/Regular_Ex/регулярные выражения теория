если у вас есть проблема и вы захотели решить ее с помощью регулярных выражений, то теперь у вас две проблемы.

Это шаблон для поиска в строках какой либо иноформации.

Ты можешь проверить – соответствует ли некоторая строка заданному шаблону или нет. Также можно разбивать строку
 части используя символ-разделитель или строку-шаблон.

 В регулярных выражениях принято задавать ограничение не только на «количество символов», но и на «содержание символа».
  Любая «маска» обычно состоит из двух (иногда больше) частей, первая из которых описывает «предпочтения» в символах,
 а вторая часть – их количество.

Шаблон	        Описание	                                                  Примеры
.           	Один любой символ	                                             1
\d	            Любая цифра	                                                     7
\D	            Любая нецифра	                                                 C
\s          	Пробел, перенос строки, символ табуляции	                     ‘ ‘
\S	            Что угодно, кроме пробела, табуляции, переноса строки	         f
[a-z]	        Любая буква от a до z	                                         z
[0-9]	        Любая цифра от 0 до 9.                                           8
\w	            Любой цифробуквенный символ или нижнее подчеркивание	         c
\W	            Любой не цифробуквенный символ	                                 -

примеры количества символов в маске:

Шаблон	        Описание	                                                  Примеры
A?	            Символ A встречается 0..1 раз	                                 A
B+	            Символ B встречается 1.. ∞ раз	                                 BBBB
C*	            Символ C встречается 0.. ∞ раз	                                 CCC
D{n}	        Символ D встречается n раз	                                     DDDD для шаблона D{4}
E{n,}	        Символ E встречается n.. ∞ раз	                                 EEEEEEE для шаблона E{2,}
F{n,m}	        Символ F встречается n..m раз	                                 EEEE, для шаблона E{2,4}


Шаблон	         Описание	                                                    Примеры
[a-d]?	         Символы a-d встречаются 0..1 раз	                           a, b, c, d
[b-d,z]+	     Символы b,c,d,z встречаются 1.. ∞ раз	                 b, bcdcdbdbdbdbzzzzbbzbzb, zbz
[1,7-9]*	     Символы 1,7,8,9 встречаются 0.. ∞ раз	                       1, 7, 9, 9777, 111199
1{5}	         Символ 1 встречается 5 раз                                     	11111
[1,2,a,b]{2}	 Символы 1,2,a,b встречаются 2 раза	                      11, 12, 1a, ab, 2b, bb, 22
[a,0]{2,3}	     Символы a,0 встречаются 2..3 раз	                     aa, a0,00,0a, aaa,000, a00,0a0, a0a


«^» — означает, что подстрока обязана включать начало строки.

«$» — означает, что подстрока обязана включать конец строки.



В регулярных выражениях символы «[ ] \ / ^ $ . | ? * + ( ) { }» имеют специальное значение. Их еще называют
«управляющие символы». Поэтому просто так их использовать в строке нельзя.

Как и в Java их необходимо экранировать. Для этого, как и в Java, используется символ «\».

Если мы хотим описать, что строка должна состоять из трех символов «?», то нельзя писать так: ?{3},
т.к. символ «?» является управляющим. Надо сделать так: \?{3}, если мы хотим задать символ «\», то надо написать «\\».

В java, в файлах с кодом, внутри строк символ «\» тоже нужно экранировать, т.к. он является управляющим.

 Так вот, если ты попытаешься задать шаблон регулярного выражения в java внутри строки, то тебе нужно будет
экранировать символ \ дважды.

Пример:

Я хочу задать маску «c:\что-угодно»
Регулярное выражение, по идее, должно выглядеть так:
один символ «с»,
двоеточие,
слеш,
точка и звездочка (для обозначения любого количества символов).Я добавил пробелов для лучшей читабельности:
c : \ .*
Но символы «\» и «.» нужно экранировать, поэтому регулярное выражение будет выглядеть так:
c :  \\\.*
Или, без пробелов
c:\\\.*
В регулярном выражении у нас должно быть три слеша (слеш – косая черта)
Поэтому регулярное выражение в java-файле будет выглядеть так:
String regexp = "c:\\\\\\.*";

Можно написать группу символов, заранее заложенную в java. Например, всю пунктуацию.
«Pattern.compile("\p{ИмяГруппы}")
\p{Punct} — все знаки пунктуации (!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~)

\p{Lower}	A lower-case alphabetic character: [a-z]
\p{Upper}	An upper-case alphabetic character:[A-Z]
\p{ASCII}	All ASCII:[\x00-\x7F]
\p{Alpha}	An alphabetic character:[\p{Lower}\p{Upper}]
\p{Digit}	A decimal digit: [0-9]
\p{Alnum}	An alphanumeric character:[\p{Alpha}\p{Digit}]
\p{Punct}	Punctuation: One of !"#$%&'()*+,-./:;<=>?@[\]^_`{|}~
\p{Graph}	A visible character: [\p{Alnum}\p{Punct}]
\p{Print}	A printable character: [\p{Graph}\x20]
\p{Blank}	A space or a tab: [ \t]
\p{Cntrl}	A control character: [\x00-\x1F\x7F]
\p{XDigit}	A hexadecimal digit: [0-9a-fA-F]
\p{Space}	A whitespace character: [ \t\n\x0B\f\r]

В Java для этого есть пакет классов java.util.regex. Там два класса Pattern и Matcher. Matcher - это объект, который
 ищет в указанном тексте совпадения с регулярным выражением и выдает их в качестве результата своей работы.
 Класс Pattern позволяет получить такой объект Matcher для составленного регулярного выражения.

Достаточно будет запомнить следующее:

1. Pattern pattern = Pattern.compile("[a-z]+");
Методом .compile() превращаем регулярное выражение "[a-z]+" (или любое другое) в объект Pattern.
 (так мы объясняем программе, что будем использовать для поиска рег. выр. "[a-z]+")

2. Matcher matcher = pattern.matcher(text);
Создаем объект Matcher для объекта pattern. В конструктор передаем text (переменная типа String),
 в котором будем искать совпадения. (так мы объясняем программе, что искать совпадения будем в строке text)

3. matcher - это что-то вроде iterator'а для совпадений в text с регулярным выражением. Он их перебирает.

4. После создания matcher не хранит никакого значения, поэтому прежде чем с ним работать обязательно нужно выполнить
 команду matcher.find();. Это как метод .next у итератора. Теперь matcher хранит в себе первое совпадение в строке text
 с регулярным выражением. Если нужно десятое выражение, нужно вызвать 10 раз метод .find().

5. String s = matcher.group(); // получить совпадение
В строку s будет записано совпадение, которое сейчас хранит matcher (matcher от этого не перестанет его хранить).
Причем .group()  (тоже что .group(0))  вернет все найденной совпадение целиком, а, например, .group(2) вернет только
вторую его группу. Что такое группа, это узнаете из книги.

6. Если после 10 совпадения снова понадобилось первое - нужно сбросить matcher методом reset(),
а затем снова дойти до первого значения (вызвав один раз метод .find()).

Всё. Это все, что надо знать. Во все остальные дебри можно не лезть.



Создание регулярных выражений в Java
Чтобы создать RegEx в Java, нужно сделать два простых шага:
написать его в виде строки с учётом синтаксиса регулярных выражений;
скомпилировать эту строку в регулярное выражение;
Работа с регулярными выражениями в любой Java-программе начинается с создания объекта класса Pattern. Для этого
необходимо вызвать один из двух имеющихся в классе статических методов compile. Первый метод принимает один
 аргумент – строковый литерал регулярного выражения, а второй – плюс еще параметр,
  включающий режим сравнения шаблона с текстом:

public static Pattern compile (String literal)
public static Pattern compile (String literal, int flags)

Список возможных значений параметра flags определен в классе Pattern и доступен нам как статические переменные класса.
 Например:

Pattern pattern = Pattern.compile("java", Pattern.CASE_INSENSITIVE);//поиск совпадений с шаблоном будет производиться без учета регистра символов.

По сути, класс Pattern — это конструктор регулярных выражений. Под «капотом» метод compile вызывает закрытый конструктор
 класса Pattern для создания скомпилированного представления. Такой способ создания экземпляра шаблона реализован
  с целью создания его в виде неизменяемого объекта. При создании производится синтаксическая проверка регулярного
   выражения.
 При наличии ошибок в строке – генерируется исключение PatternSyntaxException.
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.

нормально расписано ниже:

1. Метасимволы для поиска совпадений границ строк или текста
Метасимвол	Назначение
^	начало строки
$	конец строки
\b	граница слова
\B	не граница слова
\A	начало ввода
\G	конец предыдущего совпадения
\Z	конец ввода
\z	конец ввода

2. Метасимволы для поиска символьных классов
Метасимвол	Назначение
\d	цифровой символ
\D	нецифровой символ
\s	символ пробела
\S	непробельный символ
\w	буквенно-цифровой символ или знак подчёркивания
\W	любой символ, кроме буквенного, цифрового или знака подчёркивания
.	любой символ

3. Метасимволы для поиска символов редактирования текста
Метасимвол	Назначение
\t	символ табуляции
\n	символ новой строки
\r	символ возврата каретки
\f	переход на новую страницу
\u 0085	символ следующей строки
\u 2028	символ разделения строк
\u 2029	символ разделения абзацев

4. Метасимволы для группировки символов
Метасимвол	Назначение
[абв]	любой из перечисленных (а,б, или в)
[^абв]	любой, кроме перечисленных (не а,б, в)
[a-zA-Z]	слияние диапазонов (латинские символы от a до z без учета регистра )
[a-d[m-p]]	объединение символов (от a до d и от m до p)
[a-z&&[def]]	пересечение символов (символы d,e,f)
[a-z&&[^bc]]	вычитание символов (символы a, d-z)

5. Метасимволы для обозначения количества символов – квантификаторы. Квантификатор всегда следует после символа или группы символов.
Метасимвол	Назначение
?	один или отсутствует
*	ноль или более раз
+	один или более раз
{n}	n раз
{n,}	n раз и более
{n,m}	не менее n раз и не более m раз







