В Java 7 конструкция try-catch была немного расширена за счет добавления «множественных catch». Смотри пример:

Java 5
try
{
  …
}
 catch (IOException ex)
{
 logger.log(ex);
 throw ex;
}
 catch (SQLException ex)
{
 logger.log(ex);
 throw ex;
}



Java 7
try
{
  …
}
 catch (IOException | SQLException ex)
{
 logger.log(ex);
 throw ex;
}


— Т.е. теперь можно писать несколько исключений через ИЛИ ( «|» — это бинарный ИЛИ)?

— Да, правда, удобно?

— Гм. А какой тип будет у этого объекта-исключения внутри блока catch?

Ведь у IOException могут быть свои методы, а у SQLException – свои.

— Тип исключения будет такой же, как и у их общего класса-предка.

— Ага. Т.е. скорее всего Exeption или RuntimeException. Почему тогда просто не написать catch(Exception e)?

— Иногда, когда программисты обрабатывают все ошибки отдельно, бывает удобно разбить их на группы и одни ошибки записать
в лог, другие пробросить выше, третьи обработать иным способом.

Т.е. такая схема призвана решить проблему дублирования catch-блоков кода для обработки разных ошибок.

— Ага. Понято. Спасибо, Элли.



— Это еще не все, я хочу еще рассказать немного про блок finally.


Как ты уже, наверное, знаешь, этот блок выполняется всегда.

Когда я говорю всегда, я имеют ввиду абсолютно всегда.

Пример:

Пример с finally
try
{
 return 1;
}
 finally
{
 return 0;
}
Тут есть return в блоке try и return в блоке finally. Так вот, результатом вызова метода будет число 0.

Блок finally выполнится, что бы ни произошло. А его метод return перезатер старое возвращаемое значение своим значением.

— Ясно.

Более того, метод может либо вернуть значение, либо выбросить исключение.

Поэтому, если в блоке try возвращается значение, а в finally выбрасывается исключение, то в результате будет исключение.

— А если в блоке try выбрасывается исключение, а в блоке finally выполняется return?

Тогда считается, что метод корректно отработал и возвращается значение, которое было передано в return.

Пример	Результа
try
{
 return 1;
}
 finally
{
 return 0;
}	0
try
{
 return 1;
}
 finally
{
 throw new RuntimeException();
}	RuntimeException
try
{
 throw new RuntimeException();
}
 finally
{
 return 0;
}	0
try
{
 throw new RuntimeException();
}
 finally
{
 throw new IOException();
}	IOException
Единственной причиной, по которой может не выполниться метод finally, может быть немедленное завершение программы
посредством вызова метода System.exit();

Пример
try
{
 System.exit(0);
 return 1;
}
 finally
{
 return 0;
}





Иерархия исключений базируется на четырех классах.

Самый базовый класс – это Throwable.

От него унаследованы классы Error и Exception.

От Exception унаследован RuntimeException.

Класс Error является базовым классом для ошибок Java-машины, таких как StackOverFlow, OutOfMemory, …

Исправить последствия таких ошибок программа обычно не может, и это приводит к ее завершению.

Действительно, что можно сделать, если для дальнейшей нормальной работы программы не хватает памяти или переполнился стек.

Класс Exception является базовым для всех обычных исключений, которые выбрасываются программой. RuntimeException – это
подкатегория исключений Exception, к которым применяются немного другие правила.

— Это какие?

— Как раз сейчас и расскажу.

Как ты, наверное, помнишь, исключения делятся на две категории checked (проверяемые) и unchecked (непроверяемые).

Если метод выкидывает checked исключения, то вызывающий его метод обязан обернуть вызов такого метода в блок try-catch.
Ну, или пробросить исключение выше (своему вызывающему), явно указав его в списке throws в сигнатуре метода.

На unchecked такие правила/ограничения не распространяются.

Так вот, все исключения, унаследованные от Exception, считаются checked. Кроме исключений, которые унаследованы от
RuntimeException – они  unchecked.