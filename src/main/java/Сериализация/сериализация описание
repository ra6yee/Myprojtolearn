Это сохранение объекта в файл на диске. Десериализация это восстановление, считывание объекта из файла.Все достаточно
просто.
— Молодец, Амиго. Приятно слышать, что ты замечаешь такие мелочи. А ты бы смог дописать код, чтобы было сохранение в
 файл и чтение из файла?

— А что там писать?! Объявил FileInputStream и FileOutputStream и передавай их в методы save & load. Тут уже ничего не
 перепутаешь — все просто.

— Рада за тебя. Итак, новая тема – сериализация.

Сериализация – это практически то же самое, что мы с тобой только что делали, только гораздо круче и встроено прямо в
 Java-машину. Java-машина умеет сохранять и загружать свои объекты. Для этого ей даже не требуются методы save & load:
 все объекты хранятся внутри Java-машины, и она имеет к ним полный доступ.

Мы просто берем объект и сохраняем его в поток/читаем из потока:

public static void main(String[] args) throws Exception
{
 Cat cat = new Cat();

 //save cat to file
 FileOutputStream fileOutput = new FileOutputStream("cat.dat");
 ObjectOutputStream outputStream = new ObjectOutputStream(fileOutput);
 outputStream.writeObject(cat);
 fileOutput.close();
 outputStream.close();

 //load cat from file
 FileInputStream fiStream = new FileInputStream("cat.dat");
 ObjectInputStream objectStream = new ObjectInputStream(fiStream);
 Object object = objectStream.readObject();
 fiStream.close();
 objectStream.close();

 Cat newCat = (Cat)object;
}

Итак, что еще тебе нужно знать?

Во-первых, при сериализации (неважно, используешь ты Serializable или Externalizable) обращай внимание на
переменные static.

При использовании Serializable эти поля вообще не сериализуются (и, соответственно, их значение не меняется,
 т.к. static поля принадлежат классу, а не объекту). А вот при использовании Externalizable ты управляешь процессом сам,
  поэтому технически сделать это можно. Но не рекомендуется, так как это чревато трудноуловимыми ошибками.

Во-вторых, внимание стоит также обратить на переменные с модификатором final. При использовании Serializable они
сериализуются и десериализуются как обычно, а вот при использовании Externalizable десериализовать
final-переменную невозможно!

Причина проста: все final-поля инициализируются при вызове конструктора по умолчанию, и после этого их значение уже
невозможно изменить. Поэтому для сериализации объектов, содержащих final-поля, используй стандартную сериализацию через
Serializable.

В-третьих, при использовании наследования, все классы-наследники, происходящие от какого-то Externalizable-класса, тоже
 должны иметь конструкторы по умолчанию.



 При сериализации объекта сериализуются все объекты, на которые он ссылается в своих переменных экземпляра. И если те
 объекты тоже ссылаются на третьи объекты, они тоже сериализуются.
  И так до бесконечности. Все классы в этой цепочке должны быть Serializable, иначе их невозможно будет сериализовать
  и будет выброшено исключение.

