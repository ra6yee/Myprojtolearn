ArrayList - автоматически расширяемый массив. Вы можете работать с массивом,
но при этом не используются квадратные скобки.

Массивы имеют фиксированную длину, и после того как массив создан, он не может расти или уменьшаться.
ArrayList может менять свой размер во время исполнения программы,
 при этом не обязательно указывать размерность при создании объекта.
 Кроме того, вы без проблем можете вставить новый элемент в середину коллекции.
 А также спокойно удалить элемент из любого места.
 Элементы ArrayList могут быть абсолютно любых типов в том числе и null.
  Это удобно, когда вы не знаете точного размера массива.

Работать с ArrayList просто: создайте нужный объект, вставьте объект методом add(), обращайтесь к нему методом get(),
 используйте индексирование так же, как для массивов, но без квадратных скобок.
 ArrayList также содержит метод size(), который возвращает текущее количество элементов в массиве.

Переменные принято называть во множественном числе.


ArrayList<String> mCatNames = new ArrayList<>();
В обобщениях можно использовать только объекты классов. Поэтому запись ArrayList<int> не прокатит.
 В таких случаях следует использовать класс Integer: ArrayList<Integer>.
  Но с другой стороны это чревато большим расходом памяти.

Если у вас есть собственный класс, то он используется таким же образом, только с использованием ключевого слова new.


ArrayList<Cat> cats = new ArrayList<>();
cats.add(new Cat("Васька"));
cats.add(new Cat("Барсик"));
Метод add()
Метод add() самый популярный и не требует особых объяснений. Только не забывайте
что существует перегруженная версия метода, позволяющая вставлять элемент в нужную позицию.


cats.add(2, new Cat("Рыжик"));
Следует быть осторожным, чтобы ненароком не вставить в несуществующую позицию.
По возможности, избегайте операций вставки в середину коллекции.
Ведь системе приходится заново пересчитывать индексы элементов.

Методы ensureCapacity() и trimToSize()
Если заранее известно, сколько элементов следует хранить, то перед заполнением массива вызовите метод ensureCapacity():


mCatNames.ensureCapacity(100);
Первоначальную ёмкость можно задать и в конструкторе в качестве параметра.


ArrayList<String> mCatNames = new ArrayList<>(100);
Если вы уверены, что списочный массив будет иметь постоянный размер, то можете использовать метод trimToSize().
 Это может способствовать рациональному использованию памяти.

Метод indexOf()
Предположим, мы внимательно следим за Рыжиком. Когда он был последним, то его легко было вычислить.
 Зная размер массива, мы вычитали единицу и получали к нему доступ.
  Но потом мы стали добавлять в массив других котов и уже не сможем понять, где теперь наш Рыжик.
   Но выход всегда есть. Существует метод indexOf(), который ищет подходящий элемент и выводит его индекс.


int index = mCatNames.indexOf("Рыжик");

// выводим имя кота и его номер в массиве
mInfoTextView.setText("Рыжик числится под номером " + index);
Не забываем, что отсчёт массива идёт с 0, если индекс равен 2, значит он является третим в массиве.

Просмотр всех элементов через цикл
Чтобы вывести всех усатых-полосатых на чистую воду, используем цикл for:


String catName = "";
for (int i = 0; i < mCatNames.size(); i++) {
    catName = catName + mCatNames.get(i) + " ";
}

mInfoTextView.setText("Все коты: " + catName);
Или укороченная запись:


String catName = "";
for (String name : mCatNames) {
    catName = catName + name + " ";
}

mInfoTextView.setText("Все коты: " + catName);
Метод contains()
Чтобы узнать, есть в массиве какой-либо элемент, можно воспользоваться методом contains(), который вернёт true или false:


mInfoTextView.setText(mCatNames.contains("Бобик") + "");
Понятно, что в нашем массиве никаких бобиков и барбосов быть не может, поэтому появится надпись false.

Метод remove() - удаление элемента
Для удаления элемента из массива используется метод remove(). Можно удалять по индексу или по объекту:


mCatNames.remove(0); // удаляем по индексу
mCatNames.remove("Васька"); // удаляем по объекту
Элементы, следующие после удалённого элемента, сдвигаются влево, а размер списочного массива уменьшается на единицу.

Метод removeAll() удаляет сразу все элементы. Но лучше использовать метод clear().

Метод removeIf() - удаление элемента по предикату (Java 8)
Раньше, если нужно было удалить элемент из списка по условию, приходилось проходить в цикле по всем элементам и
сравнивать их с условием. В Java 8 появился новый метод removeIf(), позволяющий упростить код.
 Метод использует предикат - вы указываете условие, если оно выполняется, то происходит удаление элемента из списка.


ArrayList<Integer> numList = new ArrayList<>();

numList.add(51);
numList.add(14);
numList.add(11);
numList.add(12);
numList.add(31);
numList.add(21);

System.out.println("Оригинал: " + numList.toString());
// удаляем элементы, которые больше 10 и меньше 20
numList.removeIf(i -> (i > 10 && i < 20));

System.out.println("Новый список: " + numList.toString());

// Оригинал: [51, 14, 11, 12, 31, 21]
// Новый список: [51, 31, 21]
Метод set() - замена элемента
Чтобы заменить элемент в массиве, нужно использовать метод set() с указанием индекса и новым значением.
редположим, вы обнаружили, что у вас не кот Мурзик, а кошка Мурка. Нет проблем.


mCatNames.add("Васька");
mCatNames.add("Мурзик");
mCatNames.add("Рыжик");

mCatNames.set(1, "Мурка");

mInfoTextView.setText(mCatNames.get(1) + "");
Метод clear() - очистка массива
Для очистки массива используется метод clear():


mCatNames.clear();
Метод работает гораздо быстрее похожего метода removeAll().

Метод toArray() - конвертируем в обычный массив
Также можно сконвертировать из нашего списка в обычный массив и выполнить другие операции. Читайте документацию.


ArrayList<String> days = new ArrayList<>();

days.add("Monday");
days.add("Tuesday");
days.add("Wednesday");
days.add("Thursday");
days.add("Friday");
days.add("Saturday");
days.add("Sunday");

String[] daysArray = days.toArray(new String[days.size()]);

System.out.println("Массив: " + Arrays.toString(daysArray));
Конвертация в массив может понадобится для ускорения некоторых операций,
передачи массива в качестве параметра методам, которые требуют именно массив и другие причины.

Можно было реализовать эту задачу самостоятельно - создать пустой массив,
 в цикле пройтись по элементам ArrayList и поместить каждый элемент в массив.
 Важно только проследить за размером массива, который должен совпасть с размером списка.


ArrayList<String> days = new ArrayList<>();

days.add("Monday");
days.add("Tuesday");
days.add("Wednesday");
days.add("Thursday");
days.add("Friday");
days.add("Saturday");
days.add("Sunday");

String[] daysArray = new String[days.size()];

for (int i = 0; i < days.size(); i++) {
    daysArray[i] = days.get(i);
}

System.out.println("Массив: " + Arrays.toString(daysArray));
В Java 8 появился ещё один вариант через Stream.


ArrayList<String> days = new ArrayList<>();

days.add("Monday");
days.add("Tuesday");
days.add("Wednesday");
days.add("Thursday");
days.add("Friday");
days.add("Saturday");
days.add("Sunday");

String[] daysArray = days.stream().toArray(String[]::new);

System.out.println("Массив: " + Arrays.toString(daysArray));
Сколько раз совпадают элементы
В списочном массиве значения вполне могут совпадать.
 Например, среди котов попадаются однофамильцы и мы их спокойно можем запихнуть в ArrayList.
 Но сколько раз повторяются одинаковые элементы?


ArrayList<String> cats = new ArrayList<>();
cats.add("Мурзик");
cats.add("Васька");
cats.add("Мурзик");

int count = Collections.frequency(cats, "Мурзик"); // получим результат 2
mInfoTextView.setText(String.valueOf(count)); // выводим результат в TextView
Интерфейс List
java.util.List является интерфейсом и его можно использовать вместо ArrayList следующим образом:


List<String> catnamesList = new ArrayList<String>();
Или укороченный вариант для Java 7:


List<String> catnamesList = new ArrayList<>();
Как видите, мы заменили ArrayList на List, но при этом в объявлении оставили new ArrayList().
 Всё остальное остаётся без изменений. Кстати, этот способ является рекомендуемым. Но иногда он может не подойти.

Контейнеры List гарантируют определённый порядок следования элементов.
Интерфейс List дополняет Collection несколькими методами, обеспечивающими вставку и удаление элементов в середине списка.

Существует две основные разновидности List:

Базовый контейнер ArrayList, оптимизированный для произвольного доступа к элементам,
но с относительно медленными операциями вставки/удаления элементов в середине списка.
Контейнер LinkedList, оптимизированный для последовательного доступа
с быстрыми операциями вставки/удаления в середине списка.
 Произвольный доступ к элементам LinkedList выполняется относительно медленно,
  но по широте возможностей превосходит ArrayList.
В отличие от массива контейнер List позволяет добавлять и удалять элементы после создания, а также изменяет свои размеры.

Метод contains() проверяет, присутствует ли объект в списке. Чтобы удалить объект, передайте ссылку на него методу remove().
Кроме того, если у вас имеется ссылка на объект, вы можете определить индекс объекта в List при помощи метода indexOf().

Сам List реализует более общий интерфейс коллекции Collection и можно было даже написать:


Collection<String> mCatNames = new ArrayList<String>();
Но у Collection нет методов set() и get(), поэтому работать с таким интерфейсом не очень удобно.

Для создания массива можно не только добавлять по одному объекту через метод add(), но и сразу массив через метод Arrays.asList().

Оставим пока в покое котов и создадим массив из объектов Integer.


List<Integer> numbers = Arrays.asList(1, 2, 5, 9, 11);

mInfoTextView.setText(numbers.get(2) + ""); // выводит число 5
Но у данного способа есть недостаток. Если вы определили массив таким образом,
 то уже не можете вставлять или удалять другой элемент (методы add() и delete()),
  хотя при этом можете изменять существующий элемент.


List<Integer> numbers = Arrays.asList(1, 2, 5, 9, 11);
numbers.set(2, 33); // так можно
//numbers.add(34); // нельзя, ошибка во время исполнения

mInfoTextView.setText(numbers.get(2) + "");