В Java, интерфейс Map предлагает три вида коллекций: набор ключей, набор значений и набор ключ-значение. Все они могут быть обращены в List при помощи конструктора или метода addAll(). Следующая вырезка кода демонстрирует как сделать ArrayList из Map.

//лист ключей
List keyList = new ArrayList(Map.keySet());
//лист значений
List valueList = new ArrayList(Map.values()); тут уточнить
//лист ключ-значения
List entryList = new ArrayList(Map.entrySet());

1. Пройтись по всем значениям в Map
Проход по каждой паре ключ-значение — самая базовая, основная процедура прохода по Map.
 В Java, каждая пара хранится в поле Map называемом Map.Entry.
 Map.entrySet() возвращает набор ключ-значений, потому самым эффективным способом пройтись по всем значениям Map будет:

for(Entry entry: Map.entrySet()) {
  //получить ключ
  K key = entry.getKey();            использовать это!!!!!
  //получить значение
  V value = entry.getValue();
}

Так же мы можем использовать Iterator, особенно в версиях младше JDK 1.5

Iterator itr = Map.entrySet().iterator();
while(itr.hasNext()) {
  Entry entry = itr.next();
  //получить ключ
  K key = entry.getKey();
  //получить значение
  V value = entry.getValue();
...........................................................................................................
Упорядочивание Map по ключам ещё одна часто встречаемая процедура.
Первый способ: добавить Map.Entry в список, и упорядочить с использованием компаратора, что сортирует по значениям.

List list = new ArrayList(Map.entrySet());
Collections.sort(list, new Comparator() {

  @Override
  public int compare(Entry e1, Entry e2) {
    return e1.getKey().compareTo(e2.getKey());
  }
});

Другой способ: использовать SortedMap, которая ко всему, ещё и выстраивает свои ключи по порядку.
 Но, все ключи при этом должны воплощать Comparable или приниматься компаратором.

Один из имплементированных классов SortedMap — TreeMap. Её конструктор принимает компаратор.
Следующий код показывает как превратить обычную Map в упорядоченную.

SortedMap sortedMap = new TreeMap(new Comparator() {

  @Override
  public int compare(K k1, K k2) {
    return k1.compareTo(k2);
  }

});
sortedMap.putAll(Map);

...............................................................................................
3. Упорядочивание Map по значениям
Добавление Map в список и последующая сортировка работают и в данном случае, но нужно в этот раз брать Entry.getValue().
 Код ниже почти такой же как и раньше.

List list = new ArrayList(Map.entrySet());
Collections.sort(list, new Comparator() {

  @Override
  public int compare(Entry e1, Entry e2) {
    return e1.getValue().compareTo(e2.getValue());
  }

});

Мы всё ещё можем использовать SortedMap в данном случае, но только если значения уникальны.
В таком случае, вы можете обратить пару ключ-значение в значение-ключ.
Это решение обладает строгим ограничением, и не рекомендуется мною.

................................................................................................

Для создания неизменяемой Map с использованием статического инициализатора, нам нужен супер анонимный класс,
который мы добавим в неизменяемую Map на последнем шаге инициализации.
Пожалуйста, посмотрите на вторую часть кода.
Когда будет выброшено UnsupportedOperationException, если вы запустите Test.Map.put(3,"three");.

public class Test {

  private static final Map Map;
  static {
    Map = new HashMap();
    Map.put(1, "one");
    Map.put(2, "two");
  }
}
public class Test {

  private static final Map Map;
  static {
    Map aMap = new HashMap();
    aMap.put(1, "one");
    aMap.put(2, "two");
    Map = Collections.unmodifiableMap(aMap);
  }
}
.....................................................................................................................
Порядок прохода. HashMap и HashTable не дают гарантий по упорядоченности в Map;
в частности, они не гарантируют что порядок останется тем же самым в течении времени.
Но TreeMap будет упорядочивать все значения в "естественном порядке" ключей или по компаратору.
Допустимые пары ключ-значение. HashMap позволяет иметь ключ null и значение null.
HashTable не позволяет ключ null или значение null.
Если TreeMap использует естественный порядок или компаратор не позволяет использовать ключ null,
 будет выброшено исключение.
Синхронизация. Только HashTable синхронизирована, остальные — нет.
Но, "если потокобезопасное воплощение не нужно, рекомендуется использовать HashMap вместо HashTable".
.......................................................................................................................

8. Создание пустой Map
Если Map неизменна, используйте:

Map = Collections.emptyMap();

Или, используйте любое другое воплощение. Например:

Map = new HashMap();
........................................................................................................................
Особенности ключей HashMap
Теперь давай проверим, действительно ли ключи являются уникальными?

Попробуем добавить новый элемент с уже имеющимся в мапе ключом:

public static void main(String[] args) {

   HashMap<Integer, String> passportsAndNames = new HashMap<>();

   passportsAndNames.put(212133, "Лидия Аркадьевна Бубликова");
   passportsAndNames.put(162348, "Иван Михайлович Серебряков");
   passportsAndNames.put(8082771, "Дональд Джон Трамп");
   passportsAndNames.put(162348, "Виктор Михайлович Стычкин");//повторный ключ

   System.out.println(passportsAndNames);

}

Вывод:

{212133=Лидия Аркадьевна Бубликова, 8082771=Дональд Джон Трамп, 162348=Виктор Михайлович Стычкин}

Предыдущий элемент с ключом 162348, как видишь, был перезаписан.

.....................................................................................................................
“Ключ” назвали ключом не просто так. Доступ к значениям в HashMap осуществляется по ключу
(но никак не наоборот — ключ нельзя получить по значению, ведь значения могут быть повторяющимися).

Это хорошо видно на примерах получения элемента, а также удаления элемента из HashMap:

public static void main(String[] args) {

   HashMap<Integer, String> passportsAndNames = new HashMap<>();

   passportsAndNames.put(212133, "Лидия Аркадьевна Бубликова");
   passportsAndNames.put(162348, "Иван Михайлович Серебряков");
   passportsAndNames.put(8082771, "Дональд Джон Трамп");

   String lidiaName = passportsAndNames.get(212133);
   System.out.println(lidiaName);


   passportsAndNames.remove(162348);
   System.out.println(passportsAndNames);

}

Для того, чтобы получить значение, или удалить пару из словаря,
мы должны передать в методы get() и remove() именно уникальный ключ, соответствующий этому значению.
Номерных индексов, как в массивах или списках, в HashMap нет — доступ к значению осуществляется по ключу.

Вывод в консоль:

Лидия Аркадьевна Бубликова
{212133=Лидия Аркадьевна Бубликова, 8082771=Дональд Джон Трамп}

......................................................................................................................
Проверка наличия ключа и значения

HashMap тоже позволяет это делать, причем для обеих частей пары:
у нее есть методы containsKey()(проверяет наличие какого-то ключа) и containsValue() (проверяет наличие значения).

public static void main(String[] args) {

   HashMap<Integer, String> passportsAndNames = new HashMap<>();

   passportsAndNames.put(212133, "Лидия Аркадьевна Бубликова");
   passportsAndNames.put(162348, "Иван Михайлович Серебряков");
   passportsAndNames.put(8082771, "Дональд Джон Трамп");


   System.out.println(passportsAndNames.containsKey(11111));
   System.out.println(passportsAndNames.containsValue("Дональд Джон Трамп"));

}

Вывод:

false
true
.......................................................................................................................
Объединение двух мап в одну
Еще один интересный момент — две мапы можно объединить в одну.

Для этого существует метод putAll().
Мы вызываем его у первой HashMap, передаем вторую в качестве аргумента, и элементы из второй будут добавлены в первую:

public static void main(String[] args) {

   HashMap<Integer, String> passportsAndNames = new HashMap<>();
   HashMap<Integer, String> passportsAndNames2 = new HashMap<>();

   passportsAndNames.put(212133, "Лидия Аркадьевна Бубликова");
   passportsAndNames.put(162348, "Иван Михайлович Серебряков");
   passportsAndNames.put(8082771, "Дональд Джон Трамп");

   passportsAndNames2.put(917352, "Алексей Андреевич Ермаков");
   passportsAndNames2.put(925648, "Максим Олегович Архаров");


   passportsAndNames.putAll(passportsAndNames2);
   System.out.println(passportsAndNames);

}

Вывод:

{917352=Алексей Андреевич Ермаков, 212133=Лидия Аркадьевна Бубликова, 8082771=Дональд Джон Трамп,
925648=Максим Олегович Архаров, 162348=Иван Михайлович Серебряков}

Все элементы passportsAndNames2 были скопированы в passportsAndNames.
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,ю...................................................................
создайте копию map,  идите по копии циклом, при выполнении условия для удаления, удаляйте элемент,
 но не из копии, а из оригинала map




