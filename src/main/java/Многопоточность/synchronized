Блокировка нитей. И вот как это работает.

Было выяснено, что нити мешают друг другу, когда пытаются сообща работать с общими объектами и/или ресурсами.
 Как в примере с выводом на консоль: консоль одна, а выводят на нее все нити. Непорядок.

Поэтому был придуман специальный объект – мютекс. Это как табличка на двери туалета «свободно» «занято».
 Он имеет два состояния – объект свободен и объект занят, или их еще называют заблокирован и разблокирован.

Когда какой-то нити нужен общий для всех нитей объект, она проверяет мютекс, связанный с этим объектом.
Если мютекс свободен, то нить блокирует его (помечает как занятый) и начинает использование общего ресурса.
После того, как она сделала свои дела, мютекс разблокируется (помечается как свободен).

Если же нить хочет использовать объект, а мютекс заблокирован, то нить засыпает в ожидании. Когда мютекс, наконец,
 освободится занятой нитью, наша нить тут же заблокирует его и приступит к работе.
  Аналогия с табличками для туалета один в один.
 Разработчики Java встроили этот мютекс в класс Object. Тебе даже создавать его не придется. Он есть у каждого объекта.
    Вот как это все работает:
class MyClass
{
private String name1 = "Оля";
private String name2 = "Лена";

public void swap()
{
synchronized (this)
{
String s = name1;
name1 = name2;
name2 = s;
}
}
}

 если вызывать этот код одновременно из двух нитей, то будет так:

Итоговый порядок
String s1 = name1; //Оля
name1 = name2; //Лена
name2 = s1; //Оля

String s2 = name1; //Лена
name1 = name2; //Оля
name2 = s2; //Лена

Код первой нити
String s1 = name1;
name1 = name2;
name2 = s1;
//исполняется другая нить
//исполняется другая нить
//исполняется другая нить

Код второй нити
//нить ждет, пока освободится мютекс
//нить ждет, пока освободится мютекс
//нить ждет, пока освободится мютекс
String s2 = name1;
name1 = name2;
name2 = s2;

Итог
Значения переменных были дважды обменяны местами и вернулись на первоначальное место.

— Когда одна нить заходит внутрь блока кода, помеченного словом synchronized, то Java-машина тут же блокирует мютекс
у объекта, который указан в круглых скобках после слова synchronized. Больше ни одна нить не сможет зайти в этот блок,
 пока наша нить его не покинет.
Как только наша нить выйдет из блока, помеченного synchronized, то мютекс тут же автоматически разблокируется и будет
свободен для захвата другой нитью.

— Ага. А как ты думаешь, что будет в этом случае?

Код	Описание
class MyClass
{
private String name1 = "Оля";
private String name2 = "Лена";

public void swap()
{
synchronized (this)
{
String s = name1;
name1 = name2;
name2 = s;
}
}

public void swap2()
{
synchronized (this)
{
String s = name1;
name1 = name2;
name2 = s;
}
}
}
Методы swap и swap2 имеют один и тот же мютекс – объект this.
Что будет, если одна нить вызовет метод swap, а другая – метод swap2?

— Т.к. мютекс у них один, то второй нити придется ждать, пока первая нить выйдет из блока synchronized,
 поэтому проблем с одновременным доступом тут не будет.

Хотелось бы обратить твое внимание на то, что словом synchronized может быть помечен как кусок кода, так и метод.
 Вот что это значит:


class MyClass
{
private static String name1 = "Оля";
private static String name2 = "Лена";

public synchronized void swap()
{
String s = name1;
name1 = name2;
name2 = s;
}

public static synchronized void swap2()
{
String s = name1;
name1 = name2;
name2 = s;
}
}
,.......................................................................................................................

Как работает оператор synchronized в Java
Давай познакомимся с новым ключевым словом — synchronized.

Им помечается определенный кусок нашего кода. Если блок кода помечен ключевым словом synchronized, это значит
 что блок может выполняться только одним потоком одновременно.

Синхронизацию можно реализовать по-разному. Например, создать целый синхронизированный метод:

public synchronized void doSomething() {

   //...логика метода
}

Или же написать блок кода, где синхронизация осуществляется по какому-то объекту:

public class Main {

   private Object obj = new Object();

   public void doSomething() {

       //...какая-то логика, доступная для всех потоков

       synchronized (obj) {

           //логика, которая одновременно доступна только для одного потока
       }
   }
}

Смысл прост. Если один поток зашел внутрь блока кода, который помечен словом synchronized, он моментально захватывает
 мьютекс объекта, и все другие потоки,
 которые попытаются зайти в этот же блок или метод вынуждены ждать
  пока предыдущий поток не завершит свою работу и не освободит монитор.



Некоторые важные замечания
Синхронизация в Java гарантирует, что никакие два потока не смогут выполнить синхронизированный метод одновременно или
 параллельно.

synchronized можно использовать только с методами и блоками кода. Эти методы или блоки могут быть статическими или
 не-статическими.

когда какой либо поток входит в синхронизированный метод или блок он приобретает блокировку и всякий раз, когда поток
выходит из синхронизированного метода или блока JVM снимает блокировку.
 Блокировка снимается, даже если нить оставляет синхронизированный метод после завершения из-за каких-либо ошибок или исключений.

synchronized в Java рентерабельна это означает, что если синхронизированный метод вызывает другой
синхронизированный метод, который требует такой же замок, то текущий поток, который держит замок может войти в этот
метод не приобретая замок.

Синхронизация в Java будет бросать NullPointerException если объект используемый в синхронизированном блоке null.
Например, в вышеприведенном примере кода, если замок инициализируется как null,
синхронизированный (lock) бросит NullPointerException.

Синхронизированные методы в Java вносят дополнительные затраты на производительность вашего приложения.
Так что используйте синхронизацию, когда она абсолютно необходима. Кроме того, рассмотрите вопрос об использовании
синхронизированных блоков кода для синхронизации только критических секций кода.

Вполне возможно, что и статический и не статический синхронизированные методы могут работать одновременно или
 параллельно, потому что они захватывают замок на другой объект.

В соответствии со спецификацией языка вы не можете использовать synchronized в конструкторе это приведет к
ошибке компиляции.

Не синхронизируйте по не финальному (no final) полю, потому что ссылка, на не финальное поле может измениться в любое
 время, а затем другой поток может получить синхронизацию на разных объектах и уже не будет никакой синхронизации вообще.
  Лучше всего использовать класс String, который уже неизменяемый и финальный.


 допустим, у тебя есть объект, к которому обращаются несколько нитей. Чтобы с ним не было проблем можно сделать две вещи.

Первая – все места работы с данным объектом обернуть в блоки synchronized. Но такой подход может не сработать, если
какой-то программист в своем коде будет обращаться к объекту напрямую, без блока synchronized.

Поэтому чаще всего применяется второй подход – объект делают нитебезопасным (thread-safe). Т.е. механизм synchronized
 встраивают в сам объект – объявляют его методы synchronized и/или оборачивают код внутри методов в блоки synchronized.

— Т.е все объекты, которые могут использоваться из разных нитей, а это почти все объекты программы, я должен сделать
thread-safe?

— В общем-то, да. На самом деле не все объекты программы используются из разных нитей, но обычно много. Так что, когда
ты начинаешь писать код своей нити и в ней обращаешься к различным объектам своей программы, то при вызове каждого
метода ты должен задуматься – а безопасен ли этот вызов?

— Безопасен?

— Безопасен (thread-safe) — это безопасен при вызове из разных нитей.

Вот тебе несколько примеров. Допустим, у тебя есть объект String, к которому происходит обращение из разных нитей. Как
ты уже должен был запомнить, String (и все другие примитивные типы) является immutable. А это значит, что после создания
 объект не изменяется. А значит, и «сломать» такой объект нельзя. Все immutable объекты являются thread-safe.

— Уже легче.

— Теперь, допустим, тебе нужна изменяемая строка.

— Ага, помню. Есть две вида таких строк – StringBuffer и StringBuilder. StringBuffer – это аналог StringBuilder, но у
него все методы синхронизированы. Он тоже является thread-safe?

— Да. Если тебе нужно обращаться к объекту StringBuilder из разных нитей, то нужно заменить его на StringBuffer, иначе
рано или поздно нити будут менять его одновременно и «поломают».

— А если объект, к которому происходит обращение из разных нитей, – это объект моего собственного класса? Мне тоже надо
добавлять к его методам synchronized?

— Да. Лучше всего руководствоваться таким правилом – все объекты, к которым происходит обращение из разных нитей, должны
 быть thread-safe.



 Синхронизированные блоки также полезны для улучшения многопоточности с помощью точечной синхронизации. Предположим у
 класса MsLunch есть два поля, c1 и c2, который никогда не используются вместе. Все изменения этих полей должны быть
 синхронизированы, но нет причины препятствовать обновлению поля c1 во время обновления поля с2, тем самым снижая
 эффективность многопоточности. Вместо использования синхронизированных методов или синхронизированных блоков кода с
 синхронизацией по this, мы создаем два объекта-замка, целью которых является синхронизации по ним.


 public class MsLunch {
     private long c1 = 0;
     private long c2 = 0;
     private Object lock1 = new Object();
     private Object lock2 = new Object();

     public void inc1() {
         synchronized(lock1) {
             c1++;
         }
     }

     public void inc2() {
         synchronized(lock2) {
             c2++;
         }
     }
 }

 Используйте с чрезвычайной осторожностью. Вы должны быть совершенно уверены в безопасности чередования доступа к полям.

 public void addName(String name) {
     synchronized(this) {
         lastName = name;   это из документации оракла
         nameCount++;
     }
     nameList.add(name);
 }


